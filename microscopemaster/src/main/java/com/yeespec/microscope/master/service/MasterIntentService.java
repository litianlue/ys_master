package com.yeespec.microscope.master.service;import android.app.Activity;import android.app.AlertDialog;import android.app.Dialog;import android.app.IntentService;import android.app.KeyguardManager;import android.app.Notification;import android.app.NotificationManager;import android.app.PendingIntent;import android.content.BroadcastReceiver;import android.content.Context;import android.content.DialogInterface;import android.content.Intent;import android.content.IntentFilter;import android.content.SharedPreferences;import android.hardware.usb.UsbDevice;import android.media.MediaExtractor;import android.media.MediaFormat;import android.net.ConnectivityManager;import android.net.NetworkInfo;import android.net.Uri;import android.net.wifi.WifiConfiguration;import android.net.wifi.WifiManager;import android.os.Binder;import android.os.Bundle;import android.os.Environment;import android.os.Handler;import android.os.IBinder;import android.os.Message;import android.os.Parcelable;import android.os.PowerManager;import android.support.v4.util.LogWriter;import android.text.TextUtils;import android.util.Log;import android.view.KeyEvent;import android.view.Surface;import android.view.View;import android.widget.Button;import android.widget.TextView;import android.widget.Toast;import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.JSONObject;import com.avos.avoscloud.AVException;import com.avos.avoscloud.AVLiveQuery;import com.avos.avoscloud.AVLiveQueryEventHandler;import com.avos.avoscloud.AVLiveQuerySubscribeCallback;import com.avos.avoscloud.AVObject;import com.avos.avoscloud.AVQuery;import com.avos.avoscloud.FindCallback;import com.avos.avoscloud.QueryConditions;import com.koushikdutta.async.ByteBufferList;import com.koushikdutta.async.DataEmitter;import com.koushikdutta.async.Util;import com.koushikdutta.async.callback.CompletedCallback;import com.koushikdutta.async.callback.DataCallback;import com.koushikdutta.async.future.Future;import com.koushikdutta.async.http.AsyncHttpClient;import com.koushikdutta.async.http.WebSocket;import com.yeespec.R;import com.yeespec.libuvccamera.usb.DeviceFilter;import com.yeespec.libuvccamera.usb.USBMonitor;import com.yeespec.libuvccamera.usb.UVCCamera;import com.yeespec.libuvccamera.uvccamera.encoder.MediaMuxerWrapper;import com.yeespec.libuvccamera.uvccamera.service.CameraServerHandler;import com.yeespec.libuvccamera.uvccamera.service.RestartUtil;import com.yeespec.libuvccamera.uvccamera.serviceclient.CameraClient;import com.yeespec.libuvccamera.uvccamera.serviceclient.ICameraClientCallback;import com.yeespec.libuvccamera.uvccamera.widget.CameraViewInterface;import com.yeespec.microscope.master.BaseActivity;import com.yeespec.microscope.master.activity.MasterActivity;import com.yeespec.microscope.master.activity.YeeSpecActivity;import com.yeespec.microscope.master.activity.SettingActivity;import com.yeespec.microscope.master.application.BaseApplication;import com.yeespec.microscope.master.service.server.websocket.CustomWebSocketServer;import com.yeespec.microscope.master.service.server.websocket.api.channel.CameraOperationChannel;import com.yeespec.microscope.master.service.server.websocket.api.channel.SynchronousScreenChannel;import com.yeespec.microscope.master.service.system.OnErrorListener;import com.yeespec.microscope.master.service.system.disk.ExternalHDD;import com.yeespec.microscope.master.service.system.disk.ExternalSD;import com.yeespec.microscope.utils.ConstantUtil;import com.yeespec.microscope.utils.FileSizeUtil;import com.yeespec.microscope.utils.FileUtil;import com.yeespec.microscope.utils.FileUtils;import com.yeespec.microscope.utils.MDateUtils;import com.yeespec.microscope.utils.MyFileComparator;import com.yeespec.microscope.utils.PictureUtils;import com.yeespec.microscope.utils.RequesUtils;import com.yeespec.microscope.utils.SPHelper;import com.yeespec.microscope.utils.SPUtils;import com.yeespec.microscope.utils.UIUtil;import com.yeespec.microscope.utils.bluetooth.BlueUtil;import com.yeespec.microscope.utils.bluetooth.DataUtil;import com.yeespec.microscope.utils.log.Logger;import com.yeespec.microscope.utils.sql.ConfigurationParameter;import com.yeespec.microscope.utils.sql.MSQLUtil;import com.yeespec.microscope.utils.wifi.WifiConnect;import org.json.JSONException;import java.io.DataOutputStream;import java.io.File;import java.io.IOException;import java.lang.reflect.Method;import java.nio.ByteBuffer;import java.text.DateFormat;import java.text.SimpleDateFormat;import java.util.ArrayList;import java.util.Arrays;import java.util.Collections;import java.util.Date;import java.util.HashSet;import java.util.Iterator;import java.util.List;import java.util.Random;import java.util.Set;import java.util.Timer;import java.util.TimerTask;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.ScheduledExecutorService;import java.util.concurrent.TimeUnit;import static android.app.DownloadManager.Request.NETWORK_MOBILE;import static android.app.DownloadManager.Request.NETWORK_WIFI;import static com.yeespec.microscope.master.activity.MasterActivity.EXECUTE_BRIGHTNESS_CAMMAND;import static com.yeespec.microscope.master.activity.MasterActivity.EXECUTE_ISO_CAMMAND;/** * Created by Mr.Wen on 2016/06/15. * 应用的 */public class MasterIntentService extends IntentService implements OnErrorListener {    private boolean serialPostRemove = false;    public ClientLoginCallback mloginCallback;    private int currentSaturation = 1;//自动拍照时当前拍摄的是第几张照片    private boolean isCutrrentAutoStop = false; //这轮自动拍照是否完成    private boolean isCancelAutoCamera = false;   //用户停止自动拍照标识位    private boolean isSetContrast = true;//设置标记,放大物镜只初始化一次    private boolean issetSaturation = true;//激发块只初始化一次    private boolean isSetBrightness = true;//亮度只初始化一次    private static final boolean DEBUG = false;    private static final String TAG = "MasterIntentService";    private List<Integer> percentages = new ArrayList<>();//图像百分比    private int timterInteval = 0;//时间间隔    private boolean isCalculate = false;//是否计算百分比    //用于广播提醒自动合成图片    //Binder列表 :    private MasterActivityBinder mMasterActivityBinder = new MasterActivityBinder();    private boolean mInitFlag = true;    private MasterIntentService mMasterIntentService;    private Handler mMasterActivityShowHandler;    //2016.09.21 新增 : 通知条的ID :    public static final int NOTIFICATION_ID = 0x123;   //通知条的ID号 ;    //2016.05.25 新增 : 用于连接绑定的UVCService服务 :    //private BaseApplication application;    private Date startTime2, finshtime2;    private Timer timer;    private TimerTask timerTask;    private long lfinishTime;    private long now = 0;    private int[] ligths;    private AVLiveQuery doingLiveQuery;    private boolean startRemote = true;    public MasterIntentService() {        super("MasterIntentService");    }    //  private ScheduledExecutorService  detectionWifi = Executors.newScheduledThreadPool(1);    private WifiConnect wifiConnect;    private PictureUtils pictureUtils;    @Override    public void onCreate() {        super.onCreate();        mMasterIntentService = this;        Util.SUPRESS_DEBUG_EXCEPTIONS = true;        //2016.07.17 : 新增 :        startScreenService();        acquireWakeLock();        //2016.09.20 : 添加startForeground将进程设置为前台进程 ;        showForegroundNotification();        createUsbMonitor();//设置USB监听        pictureUtils = new PictureUtils();        //listening client state        if (ConstantUtil.remoteUserName != null) {            EXECUTOR_SERVICE_SCHEDULED.schedule(new Runnable() {                @Override                public void run() {                    if (!ConstantUtil.isEnbleListening) {                        listnessReMoteLogin();                    }                }            }, 35000, TimeUnit.MILLISECONDS);        }    }    private void listnessReMoteLogin() {        startrRequesTimer();        UpdatePhoneStateTimer();        RequesUtils.IsUserInstruction();        ConstantUtil.isStartDetection = true;    }    private void remote_ClientAutoPhoto(org.json.JSONObject autophoto) throws JSONException {        if (mCameraClient != null) {            if (mCameraClient.isRecording()) {                return;            }        }        if (ConstantUtil.isFastDoubleClick()) {            return;        }        //解析自动拍照参数        String autophotolights = autophoto.getString("autophotolights");        String isAutufocus = autophoto.getString("autofocus");        String isSynthetic = autophoto.getString("synthetic");        String startTimer = autophoto.getString("autophoto_starttimer");        String tTimer = autophoto.getString("autophoto_ttimer");        String endTimer = autophoto.getString("autophoto_endtimer");        String autophotostr = autophoto.getString("autophoto_stopstr");        ConstantUtil.stopAutoPhotoStr = autophotostr;        String ConverGence = autophoto.getString("convergence");        if (ConverGence != null)            ConstantUtil.ConvergenceNumber = ConverGence;        String autophotoNumb = autophoto.getString("autophoto_count");        if (!autophotoNumb.equals("") || autophotoNumb != null) {            ConstantUtil.autoPhotoCount = Integer.valueOf(autophotoNumb);        }        //保存自动拍照参数        //SPUtils.put(getBaseContext(), "autoPhoto_startTime", startTimer);        //SPUtils.put(getBaseContext(), "autoPhoto_tTime", tTimer);        //SPUtils.put(getBaseContext(), "autoPhoto_finishTime", endTimer);        BaseApplication.getInstance().setAutoPhoto_startTime(startTimer);        BaseApplication.getInstance().setAutoPhoto_tTime(tTimer);        BaseApplication.getInstance().setAutoPhoto_finishTime(endTimer);        if (isAutufocus.equals("true")) {            ConstantUtil.isAutofocus = true;        } else {            ConstantUtil.isAutofocus = false;        }        if (isSynthetic.equals("true")) {            ConstantUtil.isSynthetic = true;        } else {            ConstantUtil.isSynthetic = false;        }        String[] strings = autophotolights.split("&");        Set<String> checkboxs = new HashSet<String>();        for (int i = 0; i < strings.length; i++) {            checkboxs.add(strings[i]);        }        SharedPreferences preferences = getApplicationContext().getSharedPreferences(ConstantUtil.CHECKBOXSTATE, 0);        SharedPreferences.Editor edit = preferences.edit();        edit.putStringSet(ConstantUtil.CHECKBOXS, checkboxs);        edit.commit();        //开始自动拍照        mMasterActivityBinder.startAutoPhoneTimer();        if (mMasterActivityShowHandler != null) {            mMasterActivityShowHandler.sendEmptyMessage(MasterActivity.SHOW_MAUTO_PHONE_TIMER);        }        if (mMasterActivityBinder != null)            mMasterActivityBinder.sendToBackgroundProgram("autophotoview", "visible");    }    private void setCilentCapture() {        if (mCameraClient != null) {            if (mCameraClient.isRecording()) {                mCurrentActivity.runOnUiThread(new Runnable() {                    @Override                    public void run() {                        UIUtil.toast(mCurrentActivity, "请先停止录像再进行设置操作", false);                    }                });                return;            }            EXECUTOR_SERVICE.execute(new Runnable() {                @Override                public void run() {                    capture();                }            });        } else            UIUtil.toast(mCurrentActivity, "Please connect camera!!!", false);    }    private void setClientConstast(org.json.JSONObject jsonObject, int postion) throws JSONException {        boolean checkstate = jsonObject.getBoolean("result");        if (checkstate) {            DataUtil.moveSate[postion][0] = DataUtil.stateI;            DataUtil.moveSate[postion][1] = DataUtil.stateII;            DataUtil.CheckNums[postion] = checkstate;        } else {            DataUtil.moveSate[postion][0] = 0;            DataUtil.moveSate[postion][1] = 0;            DataUtil.CheckNums[postion] = checkstate;        }        if (mCameraClient != null)            mMasterActivityBinder.sendToBackgroundProgram(DataUtil.CONTRASTKEY, postion + "&" + checkstate);    }    private void setDownClientGamma(int param) {        if (param == 2) {            mMasterActivityBinder.setAotoFocusGame(32, false, BaseApplication.getInstance().getGamma(), "00");        } else {            if (param < 100)                mMasterActivityBinder.setAotoFocusGame(param, false, BaseApplication.getInstance().getGamma(), "08");            else                mMasterActivityBinder.setAotoFocusGame(param, false, BaseApplication.getInstance().getGamma(), "09");        }        int gamma1 = BaseApplication.getInstance().getGamma();        gamma1 -= param;        if (gamma1 < 0)            gamma1 = 0;        BaseApplication.getInstance().setGamma(gamma1);        //更新数据到手机端        if (mCameraClient != null) {            //mCameraClient.updateMessageToPhoneMethod("mgamma",gamma1+"");            mCameraClient.setUartGamma(gamma1);        }        mPutConfigurationParameter();    }    private void setClientGamma(int mgamma) {    /* if(mMasterActivityBinder.getObjectiveSwithState(true)){                              return;                          }*/        if (mgamma == 2) {            mMasterActivityBinder.setAotoFocusGame(32, true, BaseApplication.getInstance().getGamma(), "00");        } else {            if (mgamma < 100)                mMasterActivityBinder.setAotoFocusGame(mgamma, true, BaseApplication.getInstance().getGamma(), "08");            else                mMasterActivityBinder.setAotoFocusGame(mgamma, true, BaseApplication.getInstance().getGamma(), "09");        }        int gamma = BaseApplication.getInstance().getGamma();        gamma += mgamma;        if (gamma > ConstantUtil.MAXGAMMA)            gamma = ConstantUtil.MAXGAMMA;        BaseApplication.getInstance().setGamma(gamma);        //更新数据到手机端        if (mCameraClient != null) {            // mCameraClient.updateMessageToPhoneMethod("mgamma",gamma+"");            mCameraClient.setUartGamma(gamma);        }        mPutConfigurationParameter();    }    private void setClientConstrast(int constrast) {        if (mMasterActivityBinder.getObjectiveSwithState(true)) {            return;        }        //短时间操作返回        if (ConstantUtil.isFastDoubleClick()) {            return;        }        final int paramLocal;        if (constrast > 50) {            paramLocal = 10;        } else {            paramLocal = constrast;        }        BaseApplication.getInstance().setContrast(paramLocal);        final String result = paramLocal + "X";        mMasterActivityBinder.getObjectiveSwithState(true);//开启串口动作完成限制        boolean isValidity = false;        for (int i = 0; i < ConstantUtil.OBJECTIVES.length; i++) {            if (paramLocal == ConstantUtil.OBJECTIVES[i]) {                isValidity = true;            }        }        if (!isValidity)            return;        MasterIntentService.this.setContrastState(paramLocal);    }    private void setClientSaturation(int param) {        if (mMasterActivityBinder.getObjectiveSwithState(true)) {            return;        }        BaseApplication.getInstance().setSaturation(param);        if (param == 0) {            switch (ConstantUtil.LIGHTSCOUNT) {                case 1:                    BaseApplication.getInstance().setSaturation_pos(1);                    break;                case 2:                    BaseApplication.getInstance().setSaturation_pos(2);                    break;                case 3:                    BaseApplication.getInstance().setSaturation_pos(3);                    break;                case 4:                    BaseApplication.getInstance().setSaturation_pos(4);                    break;            }        } else if (param - 1 >= 0) {            if (param == 2) {                BaseApplication.getInstance().setSaturation_pos(2);            } else if (param == 3)                BaseApplication.getInstance().setSaturation_pos(1);            else                BaseApplication.getInstance().setSaturation_pos(param - 1);        }        MasterIntentService.this.setSaturationState(param);    }    private Timer getRTimer;    private TimerTask getRTimterTask;    //定时读取手机端指令    private void UpdatePhoneStateTimer() {        AVQuery<AVObject> doingQuery = new AVQuery<>(RequesUtils.CLIENT_INSTURCTION);        doingQuery.whereEqualTo("user", ConstantUtil.remoteUserName);        doingQuery.findInBackground(new FindCallback<AVObject>() {            @Override            public void done(List<AVObject> parseObjects, AVException parseException) {                // 符合查询条件的 Todo                Log.w(TAG, "符合查询条件的 ClientInstruction" + parseObjects);            }        });        doingLiveQuery = AVLiveQuery.initWithQuery(doingQuery);        doingLiveQuery.setEventHandler(new AVLiveQueryEventHandler() {            @Override            public void done(AVLiveQuery.EventType eventType, AVObject avObject, List<String> updateKeyList) {                // 事件回调，有更新后会调用此回调函数                Log.w(TAG, "事件回调，有更新后会调用此回调函数");            }        });        doingLiveQuery.subscribeInBackground(new AVLiveQuerySubscribeCallback() {            @Override            public void done(AVException e) {                if (null == e) {                    // 订阅成功                    Log.w(TAG, "订阅成功");                    FileUtils.writeFileToLogFolder("已经订阅手机远程控制指令");                } else {                    FileUtils.writeFileToLogFolder("===================订阅手机远程指令同步异常===========================");                }            }        });        doingLiveQuery.setEventHandler(new AVLiveQueryEventHandler() {            @Override            public void onObjectCreated(AVObject avObject) {                // avObject 即为新添加的数据                // Log.w(TAG,"即为新添加的数据");            }        });        doingLiveQuery.setEventHandler(new AVLiveQueryEventHandler() {            @Override            public void onObjectUpdated(AVObject avObject, List<String> updateKeyList) {                // avObject 即为被修改的 AVObject，updateKeyList 为被修改的 key 值                //  Log.w(TAG,"avObject 即为被修改的 AVObject，updateKeyList 为被修改的 key 值");                Log.w(TAG, "updateKeyList=" + updateKeyList);                for (int i = 0; i < updateKeyList.size(); i++) {                    String updatekey = updateKeyList.get(i);                    FileUtils.writeFileToLogFolder("接收手机远程指令：updatekey" + updatekey);                    if (updatekey.equals(RequesUtils.PARAM_TYPE_CONNECT_NETWORK)) {                        String connectstr = avObject.getString(RequesUtils.PARAM_TYPE_CONNECT_NETWORK);                        final String uuid = connectstr.split("&")[0];                        final String password = connectstr.split("&")[1];                        if (wifiConnect != null) {                            connectWifi(uuid, password);                        }                    }                    if (updatekey.equals(RequesUtils.PARAM_TYPE_SATURATION)) {                        int saturation = avObject.getNumber(RequesUtils.PARAM_TYPE_SATURATION).intValue();                        setClientSaturation(saturation);                    }                    if (updatekey.equals(RequesUtils.PARAM_TYPE_CONTRAST)) {                        int constrast = avObject.getNumber(RequesUtils.PARAM_TYPE_CONTRAST).intValue();                        setClientConstrast(constrast);                    }                    if (updatekey.equals(RequesUtils.PARAM_TYPE_VESSELS)) {                        int vessels = avObject.getNumber(RequesUtils.PARAM_TYPE_VESSELS).intValue();                        ConstantUtil.CHECK_AUTOFOCUS = vessels;                        if (mCameraClient != null)                            mMasterActivityBinder.sendToBackgroundProgram("check_aotufocus_object", ConstantUtil.CHECK_AUTOFOCUS + "");                    }                    if (updatekey.equals(RequesUtils.PARAM_TYPE_ISO)) {                        int iso = avObject.getNumber(RequesUtils.PARAM_TYPE_ISO).intValue();                        BaseApplication.getInstance().setGain(iso);                        if (mMasterActivityShowHandler != null) {                            mMasterActivityShowHandler.sendMessageDelayed(mMasterActivityShowHandler.obtainMessage(EXECUTE_ISO_CAMMAND, iso, 0), 100);                        }                        mPutConfigurationParameter();                    }                    if (updatekey.equals(RequesUtils.PARAM_TYPE_BRIGHTNESS)) {                        int brightness = avObject.getNumber(RequesUtils.PARAM_TYPE_BRIGHTNESS).intValue();                        BaseApplication.getInstance().setBrightness(brightness);                        if (mMasterActivityShowHandler != null) {                            mMasterActivityShowHandler.sendMessageDelayed(mMasterActivityShowHandler.obtainMessage(EXECUTE_BRIGHTNESS_CAMMAND, brightness, 0), 100);                        }                        mPutConfigurationParameter();                    }                    if (updatekey.equals(RequesUtils.PARAM_TYPE_GAMMA)) {                        int mgamma = avObject.getNumber(RequesUtils.PARAM_TYPE_GAMMA).intValue();                        setClientGamma(mgamma);                    }                    if (updatekey.equals(RequesUtils.PARAM_TYPE_GAMMA_DOMN)) {                        int mgamma = avObject.getNumber(RequesUtils.PARAM_TYPE_GAMMA_DOMN).intValue();                        setDownClientGamma(mgamma);                    }                    //org.json.JSONObject jsonObject = avObject.getJSONObject(RequesUtils.PARAM_TYPE_CONSTAST);                    try {                        if (updatekey.equals(RequesUtils.PARAM_TYPE_CONSTAST)) {                            org.json.JSONObject jsonObject = avObject.getJSONObject(RequesUtils.PARAM_TYPE_CONSTAST);                            setClientConstast(jsonObject, jsonObject.getInt("postion"));                            RequesUtils.updateInstrcution(RequesUtils.PARAM_TYPE_CONSTAST_TYPE, getApplicationContext());                        }                    } catch (JSONException e) {                        e.printStackTrace();                    }                    // boolean caputure = avObject.getBoolean(RequesUtils.CAPTURE);                    if (updatekey.equals(RequesUtils.CAPTURE)) {                        setCilentCapture();                    }                    //  boolean recoding = avObject.getBoolean(RequesUtils.CAPTURE_STILL);                    if (updatekey.equals(RequesUtils.CAPTURE_STILL)) {                        if (!ConstantUtil.isAutoPhotoFinish) {                            return;                        }                        if (ConstantUtil.isFastDoubleClick()) {                            return;                        }                        MasterIntentService.this.record();                    }                    //  boolean autophoto_b = false;                    try {                        // autophoto_b = autophoto.getBoolean("autophoto");                        if (updatekey.equals(RequesUtils.PARAM_TYPE_AUTOPHOTO)) {                            org.json.JSONObject autophoto = avObject.getJSONObject(RequesUtils.PARAM_TYPE_AUTOPHOTO);                            remote_ClientAutoPhoto(autophoto);                        }                    } catch (JSONException e) {                        e.printStackTrace();                    }                    //  boolean stopAutoPhoto = avObject.getBoolean(RequesUtils.PARAM_TYPE_STOPAUTOPHOTO);                    if (updatekey.equals(RequesUtils.PARAM_TYPE_STOPAUTOPHOTO)) {                        mMasterActivityBinder.stopAutoPhoneTimer();                        if (mMasterActivityShowHandler != null) {                            mMasterActivityShowHandler.sendEmptyMessage(MasterActivity.SHOW_AUTO_PHONE_TIMER);                        }                        if (mMasterActivityBinder != null)                            mMasterActivityBinder.sendToBackgroundProgram("autophotoview", "gone");                    }                    // boolean autofocus_b = false;                    try {                        //  autofocus_b = autofocus.getBoolean("autofocus");                        if (updatekey.equals(RequesUtils.PARAM_TYPE_MANUAL_FOCUS)) {                            org.json.JSONObject autofocus = avObject.getJSONObject(RequesUtils.PARAM_TYPE_MANUAL_FOCUS);                            if (ConstantUtil.isStartAutofocus) {                                return;                            }                            int mNewX = autofocus.getInt("x");                            int mNewY = autofocus.getInt("y");                            Log.w(TAG, "mNewX=" + mNewX);                            Log.w(TAG, "mNewY.=" + mNewY);                            MasterIntentService.this.setScaleValueXY(mNewX / 1360, mNewY / 1040);                            MasterIntentService.this.startAutoFocus();                        }                    } catch (JSONException e) {                        e.printStackTrace();                    }                    // boolean stopAutoFocus = avObject.getBoolean(RequesUtils.PARAM_TYPE_MANUAL_FOCUS_STOP);                    if (updatekey.equals(RequesUtils.PARAM_TYPE_MANUAL_FOCUS_STOP)) {                        mMasterActivityBinder.stopAutoFocus();                    }                    //更新图片文件名                    //  Log.w("updatekey","updatekey="+updatekey);                    if (updatekey.equals(RequesUtils.PARAM_TYPE_UpDATE_PICTER)) {                        RequesUtils.updatePrivewPhoto(RequesUtils.PARAM_TYPE_UpDATE_PICTER_TYPE, getApplicationContext());                    }                    //更新缩略图                    if (updatekey.equals(RequesUtils.PARAM_TYPE_SCAL_PIC_LOAD)) {                        RequesUtils.updatePrivewPhoto(RequesUtils.PARAM_TYPE_SCAL_PIC_LOAD_TYPE, getApplicationContext());                    }                    try {                        if (updatekey.equals(RequesUtils.PARAM_TYPE_ROCKERVIEW)) {                            org.json.JSONObject rocketview = avObject.getJSONObject(RequesUtils.PARAM_TYPE_ROCKERVIEW);                            String command = rocketview.getString("command");                            if (DataUtil.isConnectBlue) {                                BlueUtil.sendMessageHandle(command);                            }                        }                    } catch (JSONException e) {                        e.printStackTrace();                    }                    // 接收需要查看图片文件名                    if (updatekey.equals(RequesUtils.PARAM_TYPE_LOAD_PIC_NAME)) {                        String picName = avObject.getString(RequesUtils.PARAM_TYPE_LOAD_PIC_NAME);                        RequesUtils.PIC_NAME = picName;                        RequesUtils.updatePrivewPhoto(RequesUtils.PARAM_TYPE_PIC_LOAD_TYPE, getApplicationContext());                    }                    // 接收需要查看缩略图片文件名                    if (updatekey.equals(RequesUtils.PARAM_TYPE_LOAD_SCAL_PIC_NAME)) {                        String scal_picName = avObject.getString(RequesUtils.PARAM_TYPE_LOAD_SCAL_PIC_NAME);                        RequesUtils.SCAL_PIC_NAME = scal_picName;                        RequesUtils.updatePrivewPhoto(RequesUtils.PARAM_TYPE_LOAD_SCAL_PIC_NAME_TYPE, getApplicationContext());                    }                    // 远程导出文件                    if (updatekey.equals(RequesUtils.PARAM_TYPE_EXPORT)) {                        org.json.JSONObject export = avObject.getJSONObject(RequesUtils.PARAM_TYPE_EXPORT);                        try {                            final int param = export.getInt("param");                            mMasterActivity.runOnUiThread(new Runnable() {                                @Override                                public void run() {                                    clientExportFile(param);                                }                            });                        } catch (JSONException e) {                            e.printStackTrace();                        }                    }                    //关机                    if (updatekey.equals(RequesUtils.PARAM_TYPE_OFF)) {                        if (mCameraClient != null) {                            mCameraClient.setSaturation(0);                        }                        try {                            Process process = Runtime.getRuntime().exec("su");                            DataOutputStream out = new DataOutputStream(                                    process.getOutputStream());                            out.writeBytes("reboot -p\n");                            out.writeBytes("exit\n");                            out.flush();                        } catch (IOException e) {                            e.printStackTrace();                        }                    }                }            }        });    }    private void connectWifi(final String uuid, final String password) {        WifiConnect.WifiCipherType mconnectType = WifiConnect.WifiCipherType.WIFICIPHER_WEP;        wifiConnect.Connect(uuid, password, mconnectType);        EXECUTOR_SERVICE_SCHEDULED.schedule(new Runnable() {            @Override            public void run() {                if (!wifiConnect.isConnectWifi()) {                    WifiConnect.WifiCipherType mconnectType = WifiConnect.WifiCipherType.WIFICIPHER_WPA;                    wifiConnect.Connect(uuid, password, mconnectType);                }            }        }, 5000, TimeUnit.MILLISECONDS);    }    private Timer requestTimer;    private TimerTask mTimerTask;    //定时查询手机端是否远程登录    private void startrRequesTimer() {        RequesUtils.padUnRegist();        AVQuery<AVObject> doingQuery = new AVQuery<>(RequesUtils.CONNECT_STATE);        doingQuery.whereEqualTo("user", ConstantUtil.remoteUserName);        doingQuery.findInBackground(new FindCallback<AVObject>() {            @Override            public void done(List<AVObject> parseObjects, AVException parseException) {                // 符合查询条件的 Todo                Log.w(TAG, "符合查询条件的 " + parseObjects);            }        });        doingLiveQuery = AVLiveQuery.initWithQuery(doingQuery);        doingLiveQuery.setEventHandler(new AVLiveQueryEventHandler() {            @Override            public void done(AVLiveQuery.EventType eventType, AVObject avObject, List<String> updateKeyList) {                Log.w(TAG, "事件回调，有更新后会调用此回调函数");            }        });        doingLiveQuery.subscribeInBackground(new AVLiveQuerySubscribeCallback() {            @Override            public void done(AVException e) {                if (null == e) {                    // 订阅成功                    FileUtils.writeFileToLogFolder("已经订阅监听手机登录状态");                } else {                    FileUtils.writeFileToLogFolder("==============================订阅手机登录异常=======================");                }            }        });        doingLiveQuery.setEventHandler(new AVLiveQueryEventHandler() {            @Override            public void onObjectCreated(AVObject avObject) {                // avObject 即为新添加的数据                Log.w(TAG, "即为新添加的数据");            }        });        doingLiveQuery.unsubscribeInBackground(new AVLiveQuerySubscribeCallback() {            @Override            public void done(AVException e) {               /* if(mCameraClient!=null){                    mCameraClient.setResponeModel(false);                    RequesUtils.padUnRegist();                }*/            }        });        doingLiveQuery.setEventHandler(new AVLiveQueryEventHandler() {            @Override            public void onObjectUpdated(AVObject avObject, List<String> updateKeyList) {                // avObject 即为被修改的 AVObject，updateKeyList 为被修改的 key 值                Log.w(TAG, "updateKeyList1111=" + updateKeyList);                ConstantUtil.isEnbleListening = true;                for (int i = 0; i < updateKeyList.size(); i++) {                    String s = updateKeyList.get(i);                    if (s.equals("heartbeat")) {                        startRemote = true;                    } else if (s.equals("phonestate")) {                        org.json.JSONObject phonestate = avObject.getJSONObject("phonestate");                        try {                            boolean flage = phonestate.getBoolean("flage");                            // long data = phonestate.getLong("date");                            //如果监听到手机端登录，开启同步数据并通知服务器平板端已经登录                            if (flage) {                                if (mCameraClient != null) {                                    mCameraClient.setResponeModel(true);                                    mloginCallback.loginState(true);                                    RequesUtils.padLogin();                                    requesTimer();                                }                            } else {                                if (mCameraClient != null) {                                    mCameraClient.setResponeModel(false);                                    Log.w(TAG, "myreqone1=" + false);                                    RequesUtils.padUnRegist();                                    if (requestTimer != null) {                                        requestTimer.cancel();                                        requestTimer = null;                                    }                                }                            }                        } catch (JSONException e) {                            FileUtils.writeFileToLogFolder("================" + "订阅手机登录状态 JSONException" + " e=" + e + "======================");                            e.printStackTrace();                        }                    }                }            }        });    }    private void requesTimer() {        startRemote = true;        if (requestTimer != null) {            requestTimer.cancel();            requestTimer = null;        }        mTimerTask = new TimerTask() {            @Override            public void run() {                if (startRemote) {                    startRemote = false;                } else {                    if (mCameraClient != null) {                        if (requestTimer != null) {                            requestTimer.cancel();                            requestTimer = null;                        }                        mCameraClient.setResponeModel(false);                        Log.w(TAG, "myreqone2=" + false);                        RequesUtils.padUnRegist();                    }                }            }        };        requestTimer = new Timer();        requestTimer.schedule(mTimerTask, 120 * 1000, 120 * 1000);//1秒后启动 每120秒查询一次    }    //kill后台进程    private void stopBackProcess() {        if (mCameraClient != null) {            mCameraClient.stopBackProcess();        }    }    //判断是否还连接摄像头   /* private boolean isConnectCamera(boolean isStop) {        boolean connectCamera = false;        if (mCameraClient != null) {            connectCamera = mCameraClient.isConnectCamera(isStop);            return connectCamera;        }        return connectCamera;    }    //判断USB是否连接上    private boolean isConnectUSB() {        boolean connectCamera = false;        if (mCameraClient != null) {            connectCamera = mCameraClient.isConnectUSB();            return connectCamera;        }        return connectCamera;    }    //获取后台进程pid    private int getBackProcessPid() {        int backProcessPid = 0;        if (mCameraClient != null) {            mInitFlag = true;            backProcessPid = mCameraClient.getBackProcessPid();        }        return backProcessPid;    }*/    @Override    public void onDestroy() {        FileUtils.writeFileToLogFolder("MasterIntentService：onDestroy");        if (doingLiveQuery != null) {            doingLiveQuery.unsubscribeInBackground(new AVLiveQuerySubscribeCallback() {                @Override                public void done(AVException e) {                    if (e != null) {                        FileUtils.writeFileToLogFolder("=========================doingLiveQuery.unsubscribeInBackground e=" + e + "==========================================");                    }                }            });        }        RequesUtils.padUnRegist();        if (requestTimer != null) {            requestTimer.cancel();        }        if (timer != null) {            timer.cancel();        }        if (autoTask != null) {            autoTask = null;        }        //应用程序销毁前 , 关闭硬件端的灯光 :        if (mCameraClient != null) {            mCameraClient.setSaturation(LIGHT_SATURATION_BLACK);        }        try {            //2016.09.02 : 注释掉代码            //            if (mUSBMonitor != null)            //                mUSBMonitor.unregister();        } catch (Exception e) {            e.printStackTrace();        }        if (mCameraClient != null) {            if (pictureSocket != null) {                if (pictureSocket.tryGet() != null)                    pictureSocket.tryGet().close();                pictureSocket = null;            }            if (optionSocket != null) {                if (optionSocket.tryGet() != null)                    optionSocket.tryGet().close();                optionSocket = null;            }            mCameraClient.clientControl(CameraClient.CLIENT_STOP);        }        if (DEBUG)            Log.v(TAG, "onDestroy:");        closeUVCCamera();        //2016.07.17 : 新增 :        // 注销广播监听接收者 ;        if (mMasterResetReciever != null) {            getApplicationContext().unregisterReceiver(mMasterResetReciever);        }        NotificationManager manager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);        manager.cancel(NOTIFICATION_ID);        //2017.02.20        releaseWakeLock();        if (mCameraClient != null) {            mCameraClient = null;        }        stopForeground(true);        super.onDestroy();    }    /**     * IntentSerivce会创建单独的worker线程来处理onHandleIntent()方法实现的代码 ;     * 当所有请求处理完成后 , IntentService会自动停止 , 因此开发者无需调用stopSel()方法 ;     */    @Override    protected void onHandleIntent(Intent intent) {        if (intent != null) {            final String action = intent.getAction();            // TODO: 2016/6/15 : 此方法是IntentService 直接执行的方法 ; 在此添加根据调用startservice的不同activity进行判断 , 然后做相应操作 :            if (MasterActivity.class.getName().equals(action)) {                //Log.i(TAG, "return onHandleIntent mMasterIntentServiceBinder");            }        }    }    @Override    public IBinder onBind(Intent intent) {        // TODO: Return the communication channel to the service.        //2016.06.15 新增 :        //判断是否是绑定了MasterActivity :        if (MasterActivity.class.getName().equals(intent.getAction())) {            InitBindMasterActivityBinder();            return mMasterActivityBinder;        }        //2016.09.02 新增 :        //判断是否是绑定了SettingActivity :        if (SettingActivity.class.getName().equals(intent.getAction())) {            return new SettingActivityBinder();        }        return null;    }    //做Bind MasterActivityBinder后的初始化 :    private void InitBindMasterActivityBinder() {        EXECUTOR_SERVICE.execute(new Runnable() {            @Override            public void run() {                int timeCount = 0;                while (mInitFlag) {                    timeCount++;                    try {                        Thread.sleep(100);                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                    //    Log.e(TAG, "return while (mInitFlag) ! ... mCameraView = " + (mCameraView == null ? "null " : "not null ") + timeCount);                    if (mMasterActivity != null) {                        if (mCameraView != null)                            mInitFlag = false;                        else {                            mCameraView = mMasterActivity.getCameraViewInterface();                        }                    }                }                openUVCCamera(0);                mCameraView.setCallback(mCallback);                if (pictureSocket == null)                    displayPictureByWebSocket();                if (optionSocket == null)                    cameraOptionByWebSocket();                if (mCameraClient != null) {                    mCameraClient.clientControl(CameraClient.CLIENT_NORMAL);                }            }        });    }    @Override    public void onRebind(Intent intent) {        //2016.06.15 新增 :        //判断是否是绑定了MasterActivity :        if (MasterActivity.class.getName().equals(intent.getAction())) {            closeUVCCamera();            InitBindMasterActivityBinder();        }        super.onRebind(intent);    }    /**     * 重写onUnbind()方法时 ,返回了true ; 下次bindService , 就会调用onRebind;     */    @Override    public boolean onUnbind(Intent intent) {        super.onUnbind(intent);        //        return super.onUnbind(intent);        return true;    //重写onUnbind()方法时 ,返回了true ; 下次bindService , 就会调用onRebind;    }    @Override    public int onStartCommand(Intent intent, int flags, int startId) {        Log.i("test", "MasterIntentService onStartCommand  =====++++++++++++=========");        super.onStartCommand(intent, flags, startId);        //        return super.onStartCommand(intent, flags, startId);        return START_REDELIVER_INTENT;    }    private void showForegroundNotification() {        //2016.09.20 : 添加startForeground将进程设置为前台进程 ;        PendingIntent pIntent = PendingIntent.getActivity(this, 0, new Intent(this, MasterActivity.class), PendingIntent.FLAG_UPDATE_CURRENT);        Notification notify = new Notification.Builder(this)                .setAutoCancel(false)                .setTicker(getResources().getString(R.string.ticker_notify))                .setContentTitle(getResources().getString(R.string.title_notify))                .setContentText(getResources().getString(R.string.text_notify))                //                .setSmallIcon(R.mipmap.ic_microscope_cells_launcher)                .setWhen(System.currentTimeMillis())                .setContentIntent(pIntent)                .build();        //        startForeground(new Random().nextInt(100), notify);        startForeground(NOTIFICATION_ID, notify);    }    @Override    public void onStart(Intent intent, int startId) {        super.onStart(intent, startId);        String currentTime = MediaMuxerWrapper.getDateTimeString();        //设置通知内容并在onReceive()这个函数执行时开启        NotificationManager manager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);        Notification notification = new Notification.Builder(this)                .setAutoCancel(false)                .setTicker(getResources().getString(R.string.ticker_notify))                .setContentTitle(getResources().getString(R.string.title_notify))                .setContentText(getResources().getString(R.string.text1_notify))                //                .setSmallIcon(R.mipmap.ic_microscope_cells_launcher)                .setWhen(System.currentTimeMillis())                //                .setContentIntent(pIntent)                .build();        //        manager.notify(new Random().nextInt(100), notification);        manager.notify(NOTIFICATION_ID, notification);    }    //--------------------------------------------------------------------------------    //主界面MasterActivity 的Binder :    //2016.06.15 新增 :    //通过继承Binder来实现IBinder类 :    public class SettingActivityBinder extends Binder {        //调用的activity把自己设置进service, 让service获得activity对象的引用 :        public void setActivity(Activity currentActivity) {            mCurrentActivity = currentActivity;        }        public void setTime(String timestr) {            if (mCameraClient != null) {                mCameraClient.sendStrToUART(timestr);            }        }        public void msetGamma(int gamma) {            if (mCameraClient != null) {                mCameraClient.mSetGamma(gamma);            }        }        public void setPutConfigurationParameter() {            mPutConfigurationParameter();        }        public void setRecolorString(String recolorstring) {            if (mCameraClient != null) {                mCameraClient.setRecolorString(recolorstring);            }        }        public void changeUVCCamera(UsbDevice usbDevice) {            //先关闭远程发送，直到手机端开始登录            if (mCameraClient == null)                mCameraClient = new CameraClient(mCurrentActivity, mCameraListener);            mCameraClient.setResponeModel(false);            Log.w(TAG, "myreqone3=" + false);            mCameraClient.select(null);            mCameraClient.connect();        }    }    //--------------------------------------------------------------------------------    //主界面MasterActivity 的Binder :    //2016.06.15 新增 :    //通过继承Binder来实现IBinder类 :    public class MasterActivityBinder extends Binder {        public void myStopBackProcess() {            stopBackProcess();        }        public void setAotoFocusGame(int gamma, boolean b, int currentstep, String speed) {            mCameraClient.mSetGamma(gamma, b, currentstep, speed);        }        /**         * 设置图片的X Y 偏移量         *         * @param x         * @param y         */        public void setTranlateXY(int x, int y) {            if (mCameraClient != null) {                mCameraClient.correctionPictureXY(x, y);            }        }        public void setUartGamma(int gamma) {            if (mCameraClient != null)                mCameraClient.setUartGamma(gamma);        }        //复位焦点电机        public void resetFocus() {            mCameraClient.mReleadFocus();        }        //调用的activity把自己设置进service, 让service获得activity对象的引用 :        public void setActivity(Activity currentActivity) {            BaseApplication.getInstance().setActivity(currentActivity);            mCurrentActivity = currentActivity;            mMasterActivity = (MasterActivity) currentActivity;            mCameraView = mMasterActivity.getCameraViewInterface();            mMasterActivityShowHandler = mMasterActivity.getActivityAsyncShowHandler();        }        public void setLoginLinstness(ClientLoginCallback loginCallback) {            mloginCallback = loginCallback;        }        public void onResume() {            if (DEBUG)                Log.v(TAG, "onResume:");            if (pictureSocket == null)                displayPictureByWebSocket();            if (optionSocket == null)                cameraOptionByWebSocket();            if (mCameraClient != null) {                mCameraClient.clientControl(CameraClient.CLIENT_NORMAL);            }        }        public void onPause() {            if (DEBUG)                Log.v(TAG, "onPause:");            try {                //2016.09.02 : 注释掉代码                //                if (mUSBMonitor != null)                //                    mUSBMonitor.unregister();            } catch (Exception e) {                e.printStackTrace();            }            if (mCameraClient != null) {                if (pictureSocket != null) {                    if (pictureSocket.tryGet() != null)                        pictureSocket.tryGet().close();                    pictureSocket = null;                }                if (optionSocket != null) {                    if (optionSocket.tryGet() != null)                        optionSocket.tryGet().close();                    optionSocket = null;                }                mCameraClient.clientControl(CameraClient.CLIENT_STOP);            }        }        public void onDestroy() {            if (DEBUG)                Log.v(TAG, "onDestroy:");            closeUVCCamera();        }        public boolean isCameraClientNotNull() {            if (mCameraClient != null)                return true;            return false;        }        public boolean getObjectiveSwithState(boolean isOn) {            if (mCameraClient != null)                return mCameraClient.getObjectiveSwithState(isOn);            return false;        }        public void uadateTPicterFileName(String filename) {            if (mCameraClient != null)                mCameraClient.uadateTPicterFileName(filename);        }        public void sendToBackgroundProgram(String type, String message) {            if (mCameraClient != null)                mCameraClient.sendToBackgroundProgram(type, message);        }        public void updateMessageToPhoneMethod(String type, String number) {            if (mCameraClient != null)                mCameraClient.updateMessageToPhoneMethod(type, number);        }        public boolean isRecording() {            return mCameraClient.isRecording();        }        public void setContrast(int contrast_abs) {            //2016.08.02 : 新增 :            setContrastState(contrast_abs);        }        public void setSaturation(int saturation_abs) {            mCameraClient.setSaturation(saturation_abs);            BaseApplication.getInstance().setSaturation(saturation_abs);            // TODO: 2016/7/10  : 根据选择的物镜倍数 ,或激发块 , 着色 来配置默认参数 :            //setConfigurationParameter();            msetConigurationParameter();        }        //2016.08.02 : 新增 : 改变物镜倍数的状态 :        public void changeContrastState() {            int multiple = BaseApplication.getInstance().getContrast();            if (ConstantUtil.OBJECTIVES.length <= 0) {                return;            }            for (int i = 0; i < ConstantUtil.OBJECTIVES.length; i++) {                if (multiple == ConstantUtil.OBJECTIVES[i]) {                    if (i == ConstantUtil.OBJECTIVES.length - 1) {                        multiple = ConstantUtil.OBJECTIVES[0];                    } else {                        multiple = ConstantUtil.OBJECTIVES[i + 1];                    }                    break;                }            }            setContrastState(multiple);            FileUtils.writeFileToLogFolder("用户切换了物镜倍数为:" + multiple);        }        public void msetContrastState(int multiple) {            setContrastState(multiple);        }        //2016..09.22 : 新增 : 复位激发块的灯光状态 :关灯        public void resetSaturationState() {            // SPUtils.put(getApplicationContext(), "saturation-pos", 4);//初始化为关灯            //SPUtils.put(getApplicationContext(), "saturation", 0);            BaseApplication.getInstance().setSaturation(0);            BaseApplication.getInstance().setSaturation_pos(4);            ConstantUtil.SaturationString = "BlackLight";            // SPUtils.put(getApplicationContext(), "currentSaturationString", "BlackLight");            BaseApplication.getInstance().setCurrentSaturationString("BlackLight");            MasterIntentService.this.setSaturationState(0);        }        //2016..09.22 : 新增 : 复位激发块的灯光状态 :        public void setSaturationState(int saturation_abs) {            MasterIntentService.this.setSaturationState(saturation_abs);        }        public void sendStringToUart(String str) {            if (mCameraClient != null)                mCameraClient.sendStrToUART(str);        }        //2016.09.22 : 新增 : 复位物镜倍数的状态 :        public void resetContrastState() {            int multiple = BaseApplication.getInstance().getContrast();            BaseApplication.getInstance().setContrast(multiple);            BaseApplication.getInstance().setCurrent_contrast(multiple);            BaseApplication.getInstance().setCurrentContrast(multiple);            setContrastState(multiple);        }        public int getGamma() {            return mCameraClient.getGamma();        }        public void setGamma(int gamma) {            //mManualAutoFocus = true;            mCameraClient.setGamma(gamma);            //            Log.i("test", "MasterIntentService  setGamma() newGamma = " + gamma + " === ");        }        public void mReStartOpenUVC() {            if (mCameraClient != null) {                ConstantUtil.isUVCClose = true;                mCameraClient.removeSurface(mCameraView.getSurface());                mCameraClient.rCloseUVC();                ConstantUtil.isAllowOperation = false;//不允许对摄像头操作                EXECUTOR_SERVICE_SCHEDULED.schedule(new Runnable() {                    @Override                    public void run() {                        if (ConstantUtil.isUVCClose) {                            ConstantUtil.isUVCClose = false;                            ConstantUtil.isAllowOperation = true;                            mCameraClient.rOpenUVC();                            if (mCameraView.getSurface() != null)                                mCameraClient.addSurface(mCameraView.getSurface(), false);                        }                    }                }, 3000, TimeUnit.MILLISECONDS);            }        }        public int getBrightness() {            return mCameraClient.getBrightness();        }        //程序自检        public void startProgramSelfCheck() {            if (selfCheckFlag) {                selfCheckFlag = false;                mMasterActivityShowHandler.removeMessages(MasterActivity.UPDATE_AUTO_SELF_CHECK);                UIUtil.toast(mMasterActivity, "已停止程序自检", true);            } else {                selfCheckFlag = true;                UIUtil.toast(mMasterActivity, "已开启程序自检", true);            }            programSelfCheck();        }        public void mprogramSelfCheck() {            programSelfCheck();        }        public boolean isConnectCamera() {            return mCameraClient.isConnectCamera(BaseApplication.getInstance().getContrast(), BaseApplication.getInstance().getGamma());        }        public int getRestartState() {//            if(serialPostRemove)//                return  0;            return mCameraClient.getReStartState();        }        /* public void test(){             if(mCameraClient!=null){                 mCameraClient.setBrightness(22200);                 mCameraClient.setGain(32);                 mCameraClient.clientColor(-65536);             }         }*/        public void PutConfigurationParameter() {            mPutConfigurationParameter();        }        public void setRocKerState(String rockerState) {            if (mCameraClient != null) {                mCameraClient.setRocKerState(rockerState);            }        }        public int getMaxBrighness() {            if (mCameraClient != null) {                return mCameraClient.getMaxBrightness();            }            return 0;        }        public int getMaxNuberType(int type) {            if (mCameraClient != null) {                return mCameraClient.getMaxNuberType(type);            }            return 100;        }        public void setBrightness(int bright_abs) {            if (mCameraClient != null && ConstantUtil.isAllowOperation)                mCameraClient.setBrightness(bright_abs);            // TODO: 2016/7/10  : 添加保存默认参数配置 , 用于下次启动时配置            //putConfigurationParameter();            //  mPutConfigurationParameter();        }        public int getGain() {            return mCameraClient.getGain();        }        public void setGain(int gain_abs) {            // 变更ISO            if (mCameraClient != null && ConstantUtil.isAllowOperation)                mCameraClient.setGain(gain_abs);            // TODO: 2016/7/10  : 添加保存默认参数配置 , 用于下次启动时配置            // putConfigurationParameter();        }        public void clientColor(int color) {            changeClientColor(color);        }        public void clientControl(boolean status) {            mCameraClient.clientControl(status);        }        public void startRecording() {            mCameraClient.startRecording(ConstantUtil.filenumber);        }        public void addExportFilesItem() {            String mCurrentUserName = ConstantUtil.getCurrentUserName(getApplicationContext());            String exportName = ConstantUtil.EXPORT_USER_NAME;            if (exportName.equals("")) {                exportName = ConstantUtil.getCurrentUserName(getApplicationContext());            }            //            if (mCameraClient != null && mCameraClient.isRecording()) {                UIUtil.toast(mMasterIntentService, "请先停止录像再进行导出操作", false);                return;            }            ExternalSD externalSD = new ExternalSD(mMasterActivity);            ExternalHDD externalHDD = new ExternalHDD(mMasterActivity);            final File sdcard = externalSD.getSDCardDir();            File usbCard = externalHDD.getUSBCardPath();            // 20171013 v80plus 判断u盘插入方法            Log.w("MasterIntentService", "usbCard=" + usbCard.length());            long length = usbCard.length();            if (length < 41) {                UIUtil.toast(mMasterActivity, "没有检测到连接任何外界存储设备，请先连接", true);                return;            }           /* //非v80plus判断u盘入方法            if ((sdcard == null || sdcard.length() == 0) && (usbCard == null || usbCard.length() == 0)) {                UIUtil.toast(mMasterActivity, "没有检测到连接任何外界存储设备，请先连接", true);                return;            }*/            // Todo 图片文件导出操作（复制文件）            //  UIUtil.toast(mMasterActivity, " BaseApplication.DIR_NAME="+BaseApplication.DIR_NAME);            ConstantUtil.savaCurrentUser(getApplicationContext(), exportName);            final List<File> photoListFiles = PictureUtils.getPictures(getApplicationContext());            final List<File> photosScaled = PictureUtils.getPicturesScaled(getApplicationContext());            final List<File> photosScaledJpg = PictureUtils.getJpgPicturesScaled(getApplicationContext());            // Todo 视频文件导出操作（复制文件）            final List<File> videoListFiles = getMovies(getApplicationContext());            if (photoListFiles.size() + videoListFiles.size() == 0) {                UIUtil.toast(mMasterActivity, "指定文件夹中不存在需要导出的文件，请检查清楚", false);                ConstantUtil.savaCurrentUser(getApplicationContext(), mCurrentUserName);                return;            }            ConstantUtil.savaCurrentUser(getApplicationContext(), mCurrentUserName);            String exportUserName = ConstantUtil.EXPORT_USER_NAME;            File photoFile = new File(Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DCIM), exportUserName);            File videoFile = new File(Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_MOVIES), exportUserName);            long filesSize = FileSizeUtil.getFilesSizeInByte(photoFile.getPath());            filesSize += FileSizeUtil.getFilesSizeInByte(videoFile.getPath());            if (filesSize > FileUtil.getSDCardAllSize()) {                UIUtil.toast(mMasterActivity, "外置存储设备容量不足，请检查清楚", false);                return;            }            if (mCameraClient != null)                mCameraClient.clientControl(CameraClient.CLIENT_STOP);            final Dialog deleteAlertDialog;            deleteAlertDialog = new Dialog(mMasterActivity, R.style.Dialog_Radio);            deleteAlertDialog.setContentView(R.layout.dialog_export);            deleteAlertDialog.setCancelable(true);            deleteAlertDialog.setCanceledOnTouchOutside(true);            Button deleteButton = (Button) deleteAlertDialog.findViewById(R.id.btn_delete);            //                Button deleteVideoButton = (Button) deleteAlertDialog.findViewById(R.id.btn_delete_video);            Button cancleButton = (Button) deleteAlertDialog.findViewById(R.id.btn_cancle);            deleteButton.setOnClickListener(new View.OnClickListener() {                @Override                public void onClick(View v) {                    boolean isSDCard = false;                    if (sdcard != null) {                        if (sdcard.length() != 0)                            isSDCard = true;                    }                    FileUtils.writeFileToLogFolder("用户选择导出后删除文件");                    initExportFiles(photoListFiles, photosScaled, photosScaledJpg, videoListFiles, isSDCard, true);                    deleteAlertDialog.dismiss();                }            });            cancleButton.setOnClickListener(new View.OnClickListener() {                @Override                public void onClick(View v) {                    boolean isSDCard = false;                    if (sdcard != null) {                        if (sdcard.length() != 0)                            isSDCard = true;                    }                    // initExportFiles(photoListFiles, photosScaled, videoListFiles, (sdcard != null && sdcard.length() == 0) ? false : true, false);                    initExportFiles(photoListFiles, photosScaled, photosScaledJpg, videoListFiles, isSDCard, false);                    // dialog.dismiss();                    deleteAlertDialog.dismiss();                }            });            deleteAlertDialog.show();            if (mCameraClient != null)                mCameraClient.clientControl(CameraClient.CLIENT_NORMAL);        }        public void addMoreSettingItem() {            Intent intent = new Intent(mMasterIntentService, SettingActivity.class);            if (mCameraClient != null)                mCameraClient.clientControl(CameraClient.CLIENT_STOP);            mCurrentActivity.startActivity(intent);        }        public void record() {            mMasterIntentService.record();        }        public void capture() {            mMasterIntentService.capture();        }        //停止自动对焦        public void stopAutoFocus() {            ConstantUtil.isStartAutofocus = false;            isStopAutofocus = true;            mMasterActivityShowHandler.removeMessages(MasterActivity.SHOW_AUTO_FOCUS_DATA);            mMasterActivityShowHandler.sendEmptyMessage(MasterActivity.SHOW_AUTO_FOCUS_DATA);            ConstantUtil.isAutoFocusFinish = true;            mCameraClient.sendAutoFocusMessege(countAutofocus, 0, 0, false, ConstantUtil.MOVE_SPEED);//发送停止自动对焦指令            if (autoTimer != null) {                int uartGamma = mCameraClient.getUartGamma(-1);//只读                BaseApplication.getInstance().setGamma(uartGamma);                autoTimer.cancel();                autoTimer = null;            }        }        public void startAutoFocus() {            mMasterIntentService.startAutoFocus();        }        public void setScaleXY(float scaleX, float scaleY) {            setScaleValueXY(scaleX, scaleY);        }        //开始自检程序 :        public void startSelfCheck() {            mMasterIntentService.startSelfCheck();        }        //停止自检程序 :        public void stopSelfCheck() {            isfirsSelfCheck = true;            mMasterIntentService.stopSelfCheck();        }        //开始定时拍照 :        public void startAutoPhoneTimer() {            contracts = DataUtil.getContracts();            savaMoveState();            // String startTime = (String) SPUtils.get(getBaseContext(), "autoPhoto_startTime", "");            // String tTime = (String) SPUtils.get(getBaseContext(), "autoPhoto_tTime", "");            // String finishTime = (String) SPUtils.get(getBaseContext(), "autoPhoto_finishTime", "");            String startTime = BaseApplication.getInstance().getAutoPhoto_startTime();            String tTime = BaseApplication.getInstance().getAutoPhoto_tTime();            String finishTime = BaseApplication.getInstance().getAutoPhoto_finishTime();            SPHelper.getInstance().putString("starttime", startTime);            SPHelper.getInstance().putString("ttime", tTime);            SPHelper.getInstance().putString("finishtime", finishTime);            SPHelper.getInstance().putBoolean("isautofocus", ConstantUtil.isAutofocus);//            SPUtils.put(mCurrentActivity,"starttime",startTime,true);//            SPUtils.put(mCurrentActivity,"ttime",tTime,true);//            SPUtils.put(mCurrentActivity,"finishtime",finishTime,true);//            SPUtils.put(mCurrentActivity,"isautofocus",ConstantUtil.isAutofocus,true);            //获取设置拍照色灯颜色            Set<String> lightstr = new HashSet<>();            SharedPreferences lpreferences = getApplicationContext().getSharedPreferences(ConstantUtil.CHECKBOXSTATE, 0);            lightstr = lpreferences.getStringSet(ConstantUtil.CHECKBOXS, null);            String autophonestr = "自动拍照：开始时间=" + startTime + " 时间间隔=" + tTime + " 停止时间=" + finishTime                    + " 是否跟焦=" + ConstantUtil.isAutofocus + " 是否合成=" + ConstantUtil.isSynthetic + " 选择激发快=" + lightstr.toString();            FileUtils.writeFileToLogFolder(autophonestr);            long lTtime = 0;            try {                lTtime = Long.parseLong(tTime) * 1000 * 60;     //获取设置的定时拍照频率 :　分钟 ;            } catch (NumberFormatException ne) {                FileUtils.writeFileToLogFolder("======================定时拍照时间间隔参数异常：" + ne + "=========================");                ne.printStackTrace();            }            DateFormat format = new SimpleDateFormat("yyyy年MM月dd日 HH:mm");            try {                startTime2 = format.parse(startTime);                finshtime2 = format.parse(finishTime);                lfinishTime = finshtime2.getTime();                //创建定时器                timer = new Timer();                isCancelAutoCamera = false;                isCutrrentAutoStop = false;                isfirstAutoCamera = true;                percentages.clear();                timterInteval = Integer.valueOf(tTime);                ConstantUtil.isAutoPhotoFinish = false;                //自动拍照前清除数据                lastFocusFreshnes = 0;                for (int i1 = 0; i1 < 4; i1++) {                    mOperationBrigness[i1] = 0;                    mdifference[i1] = 0;                }                //获取设置拍照色灯颜色                Set<String> strings = new HashSet<>();                SharedPreferences preferences = getApplicationContext().getSharedPreferences(ConstantUtil.CHECKBOXSTATE, 0);                strings = preferences.getStringSet(ConstantUtil.CHECKBOXS, null);                if (strings == null) {                    return;                }                ligths = new int[strings.size()];                int i = 0;                Iterator iterator = strings.iterator();                while (iterator.hasNext()) {                    String s = (String) iterator.next();                    int value = Integer.valueOf(s);                    ligths[i] = value;                    i++;                }                Arrays.sort(ligths);  //进行排序                String stateStr = ConstantUtil.getStateStr();                FileUtils.writeFileToLogFolder(stateStr);                FileUtils.writeFileToLogFolder("开始自动拍照");                Log.w("process", "开始自动拍照");                timerTask = getAutoPhoneTimerTask();                if (ConstantUtil.isRestart) {                    isfirstAutoCamera = false;                    float fistfreshnes = SPHelper.getInstance().getFloat("fistfreshnes");                    mOperationBrigness[0] = fistfreshnes;                }                //启动定时器拍照 :                timer.schedule(timerTask, startTime2, lTtime);            } catch (Exception e) {                e.printStackTrace();            }            BaseApplication.getInstance().setAutoPhoto_views(3);        }        public boolean isfirstAutoCamera = true;//判断第一轮自动拍照        private int[] mdifference = new int[4];//记录自动拍照第一轮增加一个亮度差值        public float[] mOperationBrigness = new float[4];//记录自动拍照第一轮计算亮度值        private TimerTask getAutoPhoneTimerTask() {            return new TimerTask() {                @Override                public void run() {                    now = System.currentTimeMillis();                    if (now >= lfinishTime) {                        SPHelper.getInstance().putBoolean("autoflag", false);                        //SPUtils.put(getApplicationContext(), "autoflag", false,true);                        cancel();       //已经超过了定时时间 , 结束定时器 , 结束定时拍照 ;                        FileUtils.writeFileToLogFolder("自动拍照时间到，自动停止自动拍照");                        mCurrentActivity.runOnUiThread(new Runnable() {                            @Override                            public void run() {                                UIUtil.toast(getApplicationContext(), "已经停止自动拍照", false);                            }                        });                        ConstantUtil.isAutoPhotoFinish = true;                        if (ConstantUtil.isUVCClose) {                            ConstantUtil.isUVCClose = false;                            ConstantUtil.isAllowOperation = true;                            mCameraClient.rOpenUVC();                            if (mCameraView.getSurface() != null)                                mCameraClient.addSurface(mCameraView.getSurface(), false);                        }                        if (mMasterActivityShowHandler != null) {                            mMasterActivityShowHandler.sendEmptyMessage(MasterActivity.SHOW_AUTO_PHONE_TIMER);                        }                        BaseApplication.getInstance().setAutoPhoto_views(1);                        return;                    } else {                        if (mMasterActivityBinder != null) {                        } else {                            UIUtil.toast(getApplicationContext(), "正在加载中 ! . . .", true);                            return;                        }                        if (BaseApplication.getInstance().getAutoPhoto_views() == 1)                            return;                        isCalculate = true;//允许计算图片二值化百分比                        currentSaturation = 0;                        isCutrrentAutoStop = false;//正在这轮拍照中                        //开始自动拍照之前调整各参数                        //是否开启拍照跟焦                        if (ConstantUtil.isAutofocus && !isfirstAutoCamera) {                            if (ConstantUtil.AUTO_CAPUTER_CLOSEUVC)                                if (ConstantUtil.isUVCClose) {                                    ConstantUtil.isUVCClose = false;                                    ConstantUtil.isAllowOperation = true;                                    mCameraClient.rOpenUVC();//拍照之前打开摄像头                                    if (mCameraView.getSurface() != null)                                        mCameraClient.addSurface(mCameraView.getSurface(), false);                                }                            if (focusTimer != null) {                                focusTimer.cancel();                            }                            firstStepFreshnes = 0;                            twoStepFreshnes = 0;                            treeStepFreshnes = 0;                            freshnescount = 0;                            EXECUTOR_SERVICE_SCHEDULED.schedule(new Runnable() {                                @Override                                public void run() {                                    statfocusTimer(ligths, currentSaturation);                                }                            }, 5 * 1000, TimeUnit.MILLISECONDS);                        } else {                            if (ConstantUtil.AUTO_CAPUTER_CLOSEUVC)                                if (ConstantUtil.isUVCClose) {                                    ConstantUtil.isUVCClose = false;                                    ConstantUtil.isAllowOperation = true;                                    mCameraClient.rOpenUVC();//拍照之前打开摄像头                                    if (mCameraView.getSurface() != null)                                        mCameraClient.addSurface(mCameraView.getSurface(), false);                                }                            try {                                Thread.sleep(5000);                            } catch (InterruptedException e) {                                e.printStackTrace();                            }                            mCameraClient.sendToBackgroundProgram("isfillbitmap", "fill");                            delayStartCaptuer();                        }                    }                }            };        }        private void delayStartCaptuer() {            //如果还没启动用户停止自动拍照则停止            if (isCancelAutoCamera && BaseApplication.getInstance().getSaturation() == 0) {                //通知这轮自动拍照完成                if (timer != null) {                    timer.cancel();                }                isCancelAutoCamera = false;                ConstantUtil.isAutoPhotoFinish = true;                BaseApplication.getInstance().setAutoPhoto_views(1);                if (mMasterActivityShowHandler != null) {                    //创建信息 :                    Message msg = new Message();                    msg.what = MasterActivity.SHOW_AOTO_CAPTURE_VIEW;                    Bundle bundle = new Bundle();                    bundle.putBoolean(MasterActivity.FINISH_AOTO_CAPTURE, true);                    msg.setData(bundle);                    //向新线程中的Handler发送消息 ;                    mMasterActivityShowHandler.sendMessage(msg);                }                return;            }            startAutoCamer(ligths[currentSaturation]);        }        private Timer focusTimer;        private TimerTask focusTT;        private float firstStepFreshnes = 0;        private float twoStepFreshnes = 0;        private float treeStepFreshnes = 0;        private float lastFocusFreshnes = 0;        private int freshnescount = 0;        private void statfocusTimer(final int[] ligths, int saturation) {            FileUtils.writeFileToLogFolder("开始跟焦");            int saturation1 = BaseApplication.getInstance().getSaturation();            int delaytimer = 5;            switch (saturation1) {                case 1:                    delaytimer = 1;                    break;                case 2:                    delaytimer = 4;                    break;                case 3:                    delaytimer = 6;                    break;                case 4:                    delaytimer = 8;                    break;            }            mMasterActivityBinder.getObjectiveSwithState(true);//开启串口动作完成限制            mMasterActivityBinder.setSaturation(ligths[saturation]);//打开灯            EXECUTOR_SERVICE_SCHEDULED.schedule(new Runnable() {                @Override                public void run() {                    final float freshnes = mCameraClient.getFreshnes();                    FileUtils.writeFileToLogFolder("lastFocusFreshnes =" + lastFocusFreshnes + " currentfreshnes=" + freshnes);                    //Log.e("MasterIntentService", "lastFocusFreshnes=" + lastFocusFreshnes + "freshnes=" + freshnes + "  result=" + (lastFocusFreshnes / freshnes));                    //清晰度值偏差大于5%时进行自动跟焦                    if (lastFocusFreshnes > freshnes) {                        if (lastFocusFreshnes / freshnes < 1.05) {                            startAutoCamer(ligths[0]);                            focusTimer.cancel();                            return;                        }                    } else if (lastFocusFreshnes < freshnes) {                        if (lastFocusFreshnes / freshnes > 0.95) {                            startAutoCamer(ligths[0]);                            focusTimer.cancel();                            return;                        }                    }                    firstStepFreshnes = freshnes;                    mMasterActivityBinder.getObjectiveSwithState(true);//开启串口动作完成限制                    mCameraClient.mSetGamma(5, true, BaseApplication.getInstance().getGamma(), "08");                    focusTT = new TimerTask() {                        @Override                        public void run() {                            float mfreshnes = mCameraClient.getFreshnes();                            freshnescount++;                            if (freshnescount == 1) {                                twoStepFreshnes = mfreshnes;                            } else if (freshnescount == 3) {                                treeStepFreshnes = mfreshnes;                                if (treeStepFreshnes > firstStepFreshnes) {                                } else {                                    mMasterActivityBinder.getObjectiveSwithState(true);//开启串口动作完成限制                                    mCameraClient.mSetGamma(5, true, BaseApplication.getInstance().getGamma(), "08");                                }                                lastFocusFreshnes = freshnes;                                startAutoCamer(ligths[0]);                                focusTimer.cancel();                                //  Log.e("MasterIntentService","treeStepFreshnes="+treeStepFreshnes+"firstStepFreshnes="+firstStepFreshnes+"twoStepFreshnes="+twoStepFreshnes);                                return;                            }                            if (twoStepFreshnes > firstStepFreshnes) {                                // Log.e("MasterIntentService","firstStepFreshnes="+firstStepFreshnes+"twoStepFreshnes="+twoStepFreshnes);                                lastFocusFreshnes = freshnes;                                focusTimer.cancel();                                startAutoCamer(ligths[0]);                                return;                            }                            mMasterActivityBinder.getObjectiveSwithState(true);//开启串口动作完成限制                            mCameraClient.mSetGamma(5, false, BaseApplication.getInstance().getGamma(), "08");                        }                    };                    focusTimer = new Timer();                    focusTimer.schedule(focusTT, 1000, 1000);                }            }, delaytimer * 1000, TimeUnit.MILLISECONDS);        }        private int contractPosition = 0;        private int[][] contracts;        //开始拍摄对照组        private void startContractCapture() {            int x = contracts[contractPosition][0];            int y = contracts[contractPosition][1];            BlueUtil.moveXYState(x, y);            contractPosition++;            while (!BlueUtil.isFinishXY) {                try {                    Thread.sleep(200);                } catch (InterruptedException e) {                    FileUtils.writeFileToLogFolder("================" + "线程休眠异常" + " e=" + e + "======================");                    e.printStackTrace();                }            }            try {                Thread.sleep(7000);            } catch (InterruptedException e) {                FileUtils.writeFileToLogFolder("================" + "线程休眠异常" + " e=" + e + "======================");                e.printStackTrace();            }            mMasterActivityBinder.capture();   //拍照 :            //更新自动拍照进度            if (mMasterActivityShowHandler != null) {                Message msg = new Message();                msg.what = MasterActivity.SHOW_AUTOPHOTO_PROCESS;                mMasterActivityShowHandler.sendMessage(msg);            }            if (contractPosition != contracts.length) {                Log.w("MasterIntentService", "startContractCapture");                startContractCapture();            }        }        private void planOneCaputer(final int light) {            if (mCameraClient == null) {                return;            }            //Log.w("PictureUtils","currentSaturation ="+currentSaturation );            //如果自动拍照完成            if (currentSaturation >= ligths.length) {                if (DataUtil.getContracts() != null) {                    currentSaturation = 0;                }                commentCurrentCaptuer();                return;            }            //20180523            waitForCaputerDelay = 10;            while (mMasterActivityBinder.getObjectiveSwithState(true) && waitForCaputerDelay > 0) {                try {                    Thread.sleep(1000);                    waitForCaputerDelay--;                } catch (InterruptedException e) {                    e.printStackTrace();                }            }            mMasterActivityBinder.setSaturation(light);//在开始拍照前 , 点亮激发光 :            if (mMasterActivityShowHandler != null) {                //创建信息 :                Message msg = new Message();                msg.what = MasterActivity.UPDATE_AUTO_DISPLAY;                msg.arg1 = light;                //向新线程中的Handler发送消息 ;                mMasterActivityShowHandler.sendMessage(msg);            }            waitForCaputerDelay = 10;            int curents = BaseApplication.getInstance().getSaturation();            // Log.w(TAG, "curents=" + curents);            if (curents != 0) {                while (mCameraClient.getSaturationState() != curents && waitForCaputerDelay > 0) {                    try {                        Thread.sleep(1000);                        waitForCaputerDelay--;                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                }            }            try {                Thread.sleep(4000);            } catch (InterruptedException e) {                e.printStackTrace();            }            // Log.w(TAG, "curents2=" + curents);            delayCaputer(light);        }        private void commentCurrentCaptuer() {            isCutrrentAutoStop = true;//这轮拍照完成            //复位激发块位置            sendStringToUart("4A504C590601030000000000");            if (isfirstAutoCamera) {                isfirstAutoCamera = false;            }            if (ligths.length > 1 && ConstantUtil.isSynthetic) {                FileUtils.writeFileToLogFolder("这轮自动拍照完成，开始合成图片");                EXECUTOR_SERVICE.execute(new Runnable() {                    @Override                    public void run() {                        pictureUtils.pictureAutoCompound(getApplicationContext());                    }                });                //更新自动拍照进度                if (mMasterActivityShowHandler != null) {                    Message msg = new Message();                    msg.what = MasterActivity.SHOW_AUTOPHOTO_PROCESS;                    mMasterActivityShowHandler.sendMessage(msg);                }            }            //通知这轮自动拍照完成            if (timer != null && isCancelAutoCamera) {                //清除客户停止标识位                //  Log.w("PictureUtils","currentContracts=" +currentContracts);                if (DataUtil.getContracts() != null) {                    if (DataUtil.getContracts().length == currentContracts) {                        ConstantUtil.isAutoPhotoFinish = true;                        isCancelAutoCamera = false;                        timer.cancel();                        BaseApplication.getInstance().setAutoPhoto_views(1);                    }                } else {                    ConstantUtil.isAutoPhotoFinish = true;                    isCancelAutoCamera = false;                    BaseApplication.getInstance().setAutoPhoto_views(1);                }                //   Log.w("PictureUtils", "ConstantUtil.isAutoPhotoFinish=" +ConstantUtil.isAutoPhotoFinish);            }            if (mMasterActivityShowHandler != null) {                //如果是对照组更新                //创建信息 :                Message msg = new Message();                msg.what = MasterActivity.SHOW_AOTO_CAPTURE_VIEW;                Bundle bundle = new Bundle();                bundle.putBoolean(MasterActivity.FINISH_AOTO_CAPTURE, true);                msg.setData(bundle);                //向新线程中的Handler发送消息 ;                mMasterActivityShowHandler.sendMessage(msg);            }            if (DataUtil.CONTRASTPLAN == 1 && DataUtil.getContracts() != null) {                int[][] contracts = DataUtil.getContracts();                if (currentContracts != contracts.length) {                    currentSaturation = 0;                    autoPhotoPlanOne(ligths[currentSaturation]);                }            }        }        private int waitForCaputerDelay = 0;        private int currentContracts = 0;        private int removeXYDelay = 10;        //自动拍照方案一        private void autoPhotoPlanOne(final int light) {            int[][] contracts = DataUtil.getContracts();            if (contracts != null) {                int x = contracts[currentContracts][0];                int y = contracts[currentContracts][1];                removeXYDelay = 0;                BlueUtil.moveXYState(x, y);                currentContracts++;                while (!BlueUtil.isFinishXY && removeXYDelay < 180) {                    try {                        Thread.sleep(200);                        removeXYDelay++;                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                }                //  BlueUtil.isFinishXY = false;                try {                    Thread.sleep(2000);                } catch (InterruptedException e) {                    e.printStackTrace();                }                planOneCaputer(light);            } else {                planOneCaputer(light);            }        }        //自动拍照方案二        private void autoPhotoPlanTwo(final int light) {            if (mCameraClient == null) {                return;            }            //如果自动拍照完成            if (currentSaturation >= ligths.length) {                EXECUTOR_SERVICE_SCHEDULED.schedule(new Runnable() {                    @Override                    public void run() {                        isCutrrentAutoStop = true;//这轮拍照完成                        //复位激发块位置                        sendStringToUart("4A504C590601030000000000");                        if (isfirstAutoCamera) {                            isfirstAutoCamera = false;                        }                        if (ligths.length > 1 && ConstantUtil.isSynthetic) {                            // PictureUtils pictureUtils = new PictureUtils();                            EXECUTOR_SERVICE.execute(new Runnable() {                                @Override                                public void run() {                                    pictureUtils.pictureAutoCompound(getApplicationContext());                                }                            });                            //更新自动拍照进度                            if (mMasterActivityShowHandler != null) {                                Message msg = new Message();                                msg.what = MasterActivity.SHOW_AUTOPHOTO_PROCESS;                                mMasterActivityShowHandler.sendMessage(msg);                            }                        }                        //通知这轮自动拍照完成                        if (timer != null && isCancelAutoCamera) {                            //清除客户停止标识位                            isCancelAutoCamera = false;                            timer.cancel();                            ConstantUtil.isAutoPhotoFinish = true;                            BaseApplication.getInstance().setAutoPhoto_views(1);                        }                        if (mMasterActivityShowHandler != null) {                            //如果是对照组更新                            if (DataUtil.getContracts() != null) {                                int[][] contracts = DataUtil.getContracts();                                int delayUpdateTimter = contracts.length * 2500;                                EXECUTOR_SERVICE_SCHEDULED.schedule(new Runnable() {                                    @Override                                    public void run() {                                        Message msg = new Message();                                        msg.what = MasterActivity.SHOW_AOTO_CAPTURE_VIEW;                                        Bundle bundle = new Bundle();                                        bundle.putBoolean(MasterActivity.FINISH_AOTO_CAPTURE, true);                                        msg.setData(bundle);                                        //向新线程中的Handler发送消息 ;                                        mMasterActivityShowHandler.sendMessage(msg);                                    }                                }, delayUpdateTimter, TimeUnit.MILLISECONDS);                            } else {                                //创建信息 :                                Message msg = new Message();                                msg.what = MasterActivity.SHOW_AOTO_CAPTURE_VIEW;                                Bundle bundle = new Bundle();                                bundle.putBoolean(MasterActivity.FINISH_AOTO_CAPTURE, true);                                msg.setData(bundle);                                //向新线程中的Handler发送消息 ;                                mMasterActivityShowHandler.sendMessage(msg);                            }                        }                    }                }, 0, TimeUnit.MILLISECONDS);                return;            }            //2016.07.12 : 添加定时拍照熄灯时 , 保存当前的激发光 :            if (mMasterActivityBinder.getObjectiveSwithState(true))//开启串口动作完成限制            {                //                EXECUTOR_SERVICE_SCHEDULED.schedule(new Runnable() {                    @Override                    public void run() {                        startAutoCamer(light);                    }                }, 1000, TimeUnit.MILLISECONDS);                return;            }            /*int saturation = BaseApplication.getInstance().getSaturation();            if(saturation==light){                locationDelay =2000;            }*/            mMasterActivityBinder.setSaturation(light);//在开始拍照前 , 点亮激发光 :            if (mMasterActivityShowHandler != null) {                //创建信息 :                Message msg = new Message();                msg.what = MasterActivity.UPDATE_AUTO_DISPLAY;                msg.arg1 = light;                //向新线程中的Handler发送消息 ;                mMasterActivityShowHandler.sendMessage(msg);            }            int curents = BaseApplication.getInstance().getSaturation();            if (curents != 0) {                while (mCameraClient.getSaturationState() != curents) {                    try {                        Thread.sleep(200);                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                }                try {                    Thread.sleep(3000);                } catch (InterruptedException e) {                    e.printStackTrace();                }            }            delayCaputer(light);           /* AUTOCAMER_SERVICE_SCHEDULED.schedule(new Runnable() {                @Override                public void run() {                    delayCaputer(light);                }            }, locationDelay, TimeUnit.MILLISECONDS);  //延时10s后拍照 ; 10000 , 最长距离0 -> 4 大约10s走完 ;*/        }        private void startAutoCamer(final int light) {            if (DataUtil.CONTRASTPLAN == 1) {                currentContracts = 0;                autoPhotoPlanOne(light);            } else {                autoPhotoPlanTwo(light);            }        }        private String intevalAndPercentaggStr(List<Integer> integers, int inteval) {            String str = null;            StringBuffer buffer = new StringBuffer();            buffer.append(inteval + "&");            for (int i = 0; i < integers.size(); i++) {                buffer.append(integers.get(i) + "&");            }            str = buffer.toString();            return str;        }        //等待电机到位后执行拍照        private void delayCaputer(int light) {            if (mMasterActivityBinder != null) {                if (!mMasterActivityBinder.isCameraClientNotNull()) {                    UIUtil.toast(getApplicationContext(), "暂未检查到连接任何摄像头，请先连接", false);                    return;                }            } else {                UIUtil.toast(getApplicationContext(), "正在加载中 ! . . .", true);                return;            }            //明场下记录百分比值            if (light == 1 && isCalculate) {                isCalculate = false;                int picPercentage = mCameraClient.getPicPercentage(0);                Log.w("process", "picpercentage=" + picPercentage);                //根据图片判断串口是否掉线，重启应用                if (picPercentage == 100 && mOperationBrigness[0] > 0) {                    FileUtils.writeFileToLogFolder("检测到图像异常，restartApp");                    RestartUtil restartUtil = new RestartUtil();                    restartUtil.killProcess();//                    serialPostRemove  = true;                }                percentages.add(picPercentage);                String sendStr = intevalAndPercentaggStr(percentages, timterInteval);                ConstantUtil.intevalAndPercentage = sendStr;                //SPUtils.put(mCurrentActivity, "percentage", sendStr);                SPHelper.getInstance().putString("percentage", sendStr);                mCameraClient.sendToBackgroundProgram("percentage", sendStr);                try {                    Thread.sleep(2000);                } catch (InterruptedException e) {                    e.printStackTrace();                }            }            if (isfirstAutoCamera) {                //计算这张图片亮度值                final float operationBrignes = mCameraClient.getOperationBrignes();                mOperationBrigness[light - 1] = operationBrignes;                // SPUtils.put(mCurrentActivity,"fistfreshnes",operationBrignes);                SPHelper.getInstance().putFloat("fistfreshnes", operationBrignes);                //计算明场清晰度值                float freshness = mCameraClient.getFreshnes();                lastFocusFreshnes = freshness;            } else {                switch (light) {                    case 1://白                        adjustBrightnes(light);                        break;                    case 2://蓝                        // adjustBrightnes(light);                        break;                    case 3://绿                        // adjustBrightnes(light);                        break;                    case 4://紫                        // adjustBrightnes(light);                        break;                }            }            try {                Thread.sleep(2000);            } catch (InterruptedException e) {                e.printStackTrace();            }            //拍照方案 2            if (DataUtil.CONTRASTPLAN == 2) {                if (DataUtil.getContracts() != null) {                    startContractCapture();                } else {                    mMasterActivityBinder.capture();   //拍照 :                    //更新自动拍照进度                    if (mMasterActivityShowHandler != null) {                        Message msg = new Message();                        msg.what = MasterActivity.SHOW_AUTOPHOTO_PROCESS;                        mMasterActivityShowHandler.sendMessage(msg);                    }                }                contractPosition = 0;            } else {                mMasterActivityBinder.capture();   //拍照 :                //更新自动拍照进度                if (mMasterActivityShowHandler != null) {                    Message msg = new Message();                    msg.what = MasterActivity.SHOW_AUTOPHOTO_PROCESS;                    mMasterActivityShowHandler.sendMessage(msg);                }            }            String stateStr = ConstantUtil.getStateStr();            FileUtils.writeFileToLogFolder("开始拍照");            FileUtils.writeFileToLogFolder(stateStr);            try {                Thread.sleep(2000);            } catch (InterruptedException e) {                e.printStackTrace();            }            delayCloseLigth();            //延时2s后 , 熄灯 ://            EXECUTOR_SERVICE_SCHEDULED.schedule(new Runnable() {//                @Override//                public void run() {////                    // Log.i("test", "MasterActivityService auto phone  after capture() close light =====+++++====----");////                }//            }, 2000, TimeUnit.MILLISECONDS);            //方案一让线程睡眠2秒            if (DataUtil.CONTRASTPLAN == 1 && DataUtil.getContracts() != null) {                try {                    Thread.sleep(2000);                } catch (InterruptedException e) {                    e.printStackTrace();                }            }        }        private void delayCloseLigth() {            if (mMasterActivityBinder != null) {                if (!mMasterActivityBinder.isCameraClientNotNull()) {                    UIUtil.toast(getApplicationContext(), "暂未检查到连接任何摄像头，请先连接", true);                    return;                }            } else {                UIUtil.toast(getApplicationContext(), "正在加载中 ! . . .", true);                return;            }            if (currentSaturation == ligths.length - 1) {                //最后一张就熄灯                mMasterActivityBinder.getObjectiveSwithState(true);//开启串口动作完成限制                mMasterActivityBinder.setSaturation(MasterIntentService.LIGHT_SATURATION_BLACK);   //熄灯 ;                //这轮拍照完成后关闭摄像头                if (DataUtil.getContracts() != null && DataUtil.CONTRASTPLAN == 1) {                    if (ConstantUtil.AUTO_CAPUTER_CLOSEUVC)                        if (currentContracts == DataUtil.getContracts().length) {                            if (mCameraClient != null && !isCancelAutoCamera) {                                ConstantUtil.isUVCClose = true;                                mCameraClient.removeSurface(mCameraView.getSurface());                                mCameraClient.rCloseUVC();                                ConstantUtil.isAllowOperation = false;//不允许对摄像头操作                            }                        }                } else {                    if (ConstantUtil.AUTO_CAPUTER_CLOSEUVC)                        if (mCameraClient != null && !isCancelAutoCamera) {                            ConstantUtil.isUVCClose = true;                            mCameraClient.removeSurface(mCameraView.getSurface());                            mCameraClient.rCloseUVC();                            ConstantUtil.isAllowOperation = false;//不允许对摄像头操作                        }                }                BaseApplication.getInstance().setSaturation_pos(ConstantUtil.LIGHTSCOUNT);                BaseApplication.getInstance().setSaturation(0);                if (mMasterActivityShowHandler != null) {                    Message msg = new Message();                    msg.what = MasterActivity.SHOW_STATE_SATURATION;                    Bundle bundle = new Bundle();                    bundle.putInt(MasterActivity.STATE_SATURATION, MasterIntentService.LIGHT_SATURATION_BLACK);                    msg.setData(bundle);                    //向新线程中的Handler发送消息 ;                    mMasterActivityShowHandler.sendMessage(msg);                }            }            //开始拍摄下一张            currentSaturation++;            if (currentSaturation >= ligths.length) {                if (DataUtil.CONTRASTPLAN == 1 && DataUtil.getContracts() != null) {                    planOneCaputer(ligths[currentSaturation - 1]);                } else {                    startAutoCamer(ligths[currentSaturation - 1]);                    return;                }            } else {                if (DataUtil.CONTRASTPLAN == 1 && DataUtil.getContracts() != null) {                    planOneCaputer(ligths[currentSaturation]);                } else {                    startAutoCamer(ligths[currentSaturation]);                }            }        }        private void adjustBrightnes(final int light) {            int difference = 1;//增加多少个亮度            final float operationBrignes = mCameraClient.getOperationBrignes();            if (operationBrignes == mOperationBrigness[light - 1])                return;            //减少亮度            if ((operationBrignes - mOperationBrigness[light - 1]) / mOperationBrigness[light - 1] >= 0.05) {                int brightness1 = BaseApplication.getInstance().getBrightness();                if (brightness1 < 1)                    return;                FileUtils.writeFileToLogFolder("减少一个亮度，当前亮度值为：" + (brightness1 - difference));                mCameraClient.setBrightness(brightness1 - difference);                BaseApplication.getInstance().setBrightness(brightness1 - difference);                BaseApplication.getInstance().setSaturation(light);                // putConfigurationParameter();                mPutConfigurationParameter();            } else                //增加亮度                if ((mOperationBrigness[light - 1] - operationBrignes) / mOperationBrigness[light - 1] >= 0.05) {                    int brightness1 = BaseApplication.getInstance().getBrightness();                    if (brightness1 > getMaxBrighness())                        return;                    mCameraClient.setBrightness(brightness1 + difference);                    FileUtils.writeFileToLogFolder("增加一个亮度，当前亮度值为：" + (brightness1 + difference));                    BaseApplication.getInstance().setSaturation(light);                    BaseApplication.getInstance().setBrightness(brightness1 + difference);                    //putConfigurationParameter();                    mPutConfigurationParameter();                }        }        //停止自动定时拍照 :        public void stopAutoPhoneTimer() {            // SPUtils.put(getApplicationContext(), "autoflag", false,true);            SPHelper.getInstance().putBoolean("autoflag", false);            //用户停止自动拍照            isCancelAutoCamera = true;            if (isCutrrentAutoStop) {                if (timer != null) {                    timer.cancel();                    int[][] contracts = DataUtil.getContracts();                    if (contracts != null) {                        if (currentContracts == contracts.length) {                            ConstantUtil.isAutoPhotoFinish = true;                            BaseApplication.getInstance().setAutoPhoto_views(1);                        }                    } else {                        ConstantUtil.isAutoPhotoFinish = true;                        BaseApplication.getInstance().setAutoPhoto_views(1);                    }                    // BlueUtil.resateXY();                }            }            if (ConstantUtil.AUTO_CAPUTER_CLOSEUVC) {                if (ConstantUtil.isUVCClose) {                    ConstantUtil.isUVCClose = false;                    ConstantUtil.isAllowOperation = true;                    mCameraClient.rOpenUVC();//打开摄像头                    if (mCameraView.getSurface() != null)                        mCameraClient.addSurface(mCameraView.getSurface(), false);                }            } else {                ConstantUtil.isUVCClose = false;            }        }    }    private void savaMoveState() {        SPHelper.getInstance().putBoolean("autoflag", true);        //  SPUtils.put(getApplicationContext(), "autoflag", true,true);//已经开始自动拍照标志        Log.w("process", "SPUtils.put  savaMoveState=" + true);        StringBuffer moveStateX = new StringBuffer();        StringBuffer moveStateY = new StringBuffer();        if (DataUtil.CheckNums.length > 1) {            for (int i = 0; i < DataUtil.CheckNums.length; i++) {                if (DataUtil.CheckNums[i] == true) {                    moveStateX.append("" + DataUtil.moveSate[i][0] + "&");                    moveStateY.append("" + DataUtil.moveSate[i][1] + "&");                }            }            SPHelper.getInstance().putString("movestatex", moveStateX.toString());            SPHelper.getInstance().putString("movestatey", moveStateY.toString());        }    }    private void setScaleValueXY(float scaleX, float scaleY) {        mScaleX = scaleX;        mScaleY = scaleY;    }    private void changeClientColor(int color) {        if (mCameraClient != null) {            mCameraClient.clientColor(color);            //mCameraClient.setRecolorString(BaseApplication.getInstance().getCurrentSaturationString());            // TODO: 2016/7/10  : 根据选择的物镜倍数 ,或激发块 , 着色 来配置默认参数 :            mPutConfigurationParameter();        }    }    //2016.08.02 : 新增 :    public void setContrastState(int contrast_abs) {        if (mCameraClient != null) {            BaseApplication.getInstance().setContrast(contrast_abs);            mCameraClient.setContrast(contrast_abs);            // TODO: 2016/7/10  : 根据选择的物镜倍数 ,或激发块 , 着色 来配置默认参数 :            // setConfigurationParameter();            // mPutConfigurationParameter();            msetConigurationParameter();            if (mMasterActivityShowHandler != null) {                //创建信息 :                Message msg = new Message();                msg.what = MasterActivity.SHOW_STATE_CONTRAST;                Bundle bundle = new Bundle();                Log.w("test123", "test=" + contrast_abs);                bundle.putInt(MasterActivity.STATE_CONTRAST, contrast_abs);                msg.setData(bundle);                //向新线程中的Handler发送消息 ;                mMasterActivityShowHandler.sendMessage(msg);            }        }    }    //2016.08.02 : 新增 :    public void setSaturationState(int saturation_abs) {        if (mCameraClient != null) {            mCameraClient.setSaturation(saturation_abs);            BaseApplication.getInstance().setSaturation(saturation_abs);            //            //2016.07.12 : 添加定时拍照熄灯时 , 保存当前的激发光 :            // TODO: 2016/7/10  : 根据选择的物镜倍数 ,或激发块 , 着色 来配置默认参数 :            //setConfigurationParameter();            msetConigurationParameter();            //SPUtils.put(getApplicationContext(), "autophone_saturation", saturation_abs);            if (mMasterActivityShowHandler != null) {                //创建信息 :                Message msg = new Message();                msg.what = MasterActivity.SHOW_STATE_SATURATION;                Bundle bundle = new Bundle();                bundle.putInt(MasterActivity.STATE_SATURATION, saturation_abs);                msg.setData(bundle);                //向新线程中的Handler发送消息 ;                mMasterActivityShowHandler.sendMessage(msg);            }        }    }    //-------------------------------------------------------------------------------    private CameraViewInterface mCameraView;    private Activity mCurrentActivity;    private MasterActivity mMasterActivity;    public USBMonitor mUSBMonitor;    public CameraClient mCameraClient;    //创建一个可重用固定线程数的线程池    public static final ExecutorService EXECUTOR_SERVICE = Executors.newSingleThreadExecutor();    //创建一个可重用固定线程数的延时线程池    public static final ScheduledExecutorService EXECUTOR_SERVICE_SCHEDULED = Executors.newScheduledThreadPool(4);    public static final ScheduledExecutorService AUTOCAMER_SERVICE_SCHEDULED = Executors.newScheduledThreadPool(1);    //public static final ScheduledExecutorService OPERATIONBRIGHTNES_DELAY = Executors.newScheduledThreadPool(4);    //public static final ScheduledExecutorService AUTOFOCUS_SERVICE_DELAY = Executors.newScheduledThreadPool(2);    public Future<WebSocket> pictureSocket;    public Future<WebSocket> optionSocket;    // TODO: 2016/7/15 : 新版本 激发块的 输入号位 :    public static final int LIGHT_SATURATION_WHITE = 1;    public static final int LIGHT_SATURATION_BLACK = 0;    public static final int LIGHT_SATURATION_BLUE = 2;    public static final int LIGHT_SATURATION_GREEN = 3;    public static final int LIGHT_SATURATION_PURPLE = 4;    public static final int MULTIPLE_5X = 5;    public static final int MULTIPLE_10X = 10;    public static final int MULTIPLE_20X = 20;    public static final int MULTIPLE_40X = 40;    public static final int MULTIPLE_50X = 50;    public static final String MULTIPLE_STRING_5X = " 5X ";    public static final String MULTIPLE_STRING_10X = " 10X ";    public static final String MULTIPLE_STRING_20X = " 20X ";    public static final String MULTIPLE_STRING_40X = " 40X ";    public static final String MULTIPLE_STRING_50X = " 50X ";    public static final String LIGHT_STRING_WHITE = " light_white ";    public static final String LIGHT_STRING_BLACK = " light_black ";    public static final String LIGHT_STRING_BLUE = " light_blue ";    public static final String LIGHT_STRING_GREEN = " light_green ";    public static final String LIGHT_STRING_PURPLE = " light_purple ";    // private MediaPlayer shootMP;    public void tryOpenUVCCamera() {        if (DEBUG)            Log.v(TAG, "tryOpenUVCCamera:");        openUVCCamera(0);    }    public void openUVCCamera(final int index) {        if (mCameraClient == null) {            mCameraClient = new CameraClient(mCurrentActivity, mCameraListener);            //先关闭远程发送，直到手机端开始登录            mCameraClient.setResponeModel(false);            Log.w(TAG, "myreqone4=" + false);        }        mCameraClient.select(null);        mCameraClient.resize(UVCCamera.DEFAULT_PREVIEW_WIDTH, UVCCamera.DEFAULT_PREVIEW_HEIGHT);        mCameraClient.connect();        FileUtils.writeFileToLogFolder("打开摄像头");        if (mCameraClient != null) {            mCameraClient.mSetGamma(ConstantUtil.M_GAMMA);        }    }    public void closeUVCCamera() {        Log.d("MasterIntenService", "closeUVCCamera");        FileUtils.writeFileToLogFolder("关闭摄像头");        if (mCameraClient != null) {            if (mCameraView != null && mCameraView.getSurface() != null) {                mCameraClient.removeSurface(mCameraView.getSurface());            }            mCameraClient.disconnect();            mCameraClient.release();            mCameraClient.doUnBindService();            mCameraClient = null;            if (pictureSocket != null) {                if (pictureSocket.tryGet() != null)                    pictureSocket.tryGet().close();                pictureSocket = null;            }            if (optionSocket != null) {                if (optionSocket.tryGet() != null)                    optionSocket.tryGet().close();                optionSocket = null;            }        }        enableViewListener.enableView(false);    }    //USB监听的    private void createUsbMonitor() {        if (mUSBMonitor == null) {            mUSBMonitor = new USBMonitor(this, mOnDeviceConnectListener);            final List<DeviceFilter> filter = DeviceFilter.getDeviceFilters(this, R.xml.device_filter_camera);            mUSBMonitor.setDeviceFilter(filter);        }    }    private final ICameraClientCallback mCameraListener = new ICameraClientCallback() {        @Override        public void onConnect() {            if (DEBUG)                Log.v(TAG, "onConnect:");            if (mCameraClient != null) {                if (mCameraView.getSurface() != null) {                    mCameraClient.removeSurface(mCameraView.getSurface());                    mCameraClient.addSurface(mCameraView.getSurface(), false);    //2016.12.28 : 注释掉                }            }            EXECUTOR_SERVICE.execute(new Runnable() {                @Override                public void run() {                    if (mCameraClient != null)                        initializeCamera(mCameraClient);                }            });        }        @Override        public void onDisconnect() {            EXECUTOR_SERVICE.execute(new Runnable() {                @Override                public void run() {                    enableViewListener.enableView(false);                }            });        }        @Override        public void isConnect(boolean b) {            if (!b) {                ConstantUtil.isUVCClose = true;                mCameraClient.removeSurface(mCameraView.getSurface());                mCameraClient.rCloseUVC();                ConstantUtil.isAllowOperation = false;//不允许对摄像头操作                ConstantUtil.UVCServiceConnectStion = 2;                mCurrentActivity.runOnUiThread(new Runnable() {                    @Override                    public void run() {                        UIUtil.toast(getApplicationContext(), "服务正在重启,请稍后", false);                        FileUtils.writeFileToLogFolder("服务重启");                    }                });            } else {                if (isUVCServiceFristConnect) {                    isUVCServiceFristConnect = false;                } else                    ConstantUtil.UVCServiceConnectStion = 3;            }            if (mCameraClient != null && (ConstantUtil.UVCServiceConnectStion == 3)) {                if (ConstantUtil.isUVCClose) {                    ConstantUtil.isUVCClose = false;                    ConstantUtil.isAllowOperation = true;                    mCameraClient.rOpenUVC();                    if (mCameraView.getSurface() != null)                        mCameraClient.addSurface(mCameraView.getSurface(), false);                    ConstantUtil.UVCServiceConnectStion = 1;                }                ftimerTask = new TimerTask() {                    @Override                    public void run() {                        ftimer.cancel();                        Intent intent = new Intent(getApplicationContext(), YeeSpecActivity.class);                        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); //                        intent.setAction(Intent.ACTION_DIAL);                        startActivity(intent);                    }                };                ftimer = new Timer();                ftimer.schedule(ftimerTask, 1000, 100);            }        }    };    private Timer ftimer;    private TimerTask ftimerTask;    private boolean isUVCServiceFristConnect = true;    public final USBMonitor.OnDeviceConnectListener mOnDeviceConnectListener = new USBMonitor.OnDeviceConnectListener() {        @Override        public void onAttach(final UsbDevice device) {            if (mCameraClient != null) {            }            if (device == null)                return;            if (!isUsbDevAUvcCamera(device)) {            }        }        private boolean isUsbDevAUvcCamera(UsbDevice device) {            if (device.getDeviceClass() == 239 && device.getDeviceSubclass() == 2) {                return true;            }            return false;        }        @Override        public void onConnect(final UsbDevice device, final USBMonitor.UsbControlBlock ctrlBlock, final boolean createNew) {        }        @Override        public void onDisconnect(final UsbDevice device, final USBMonitor.UsbControlBlock ctrlBlock) {        }        /**         * 只处理相机设备断线，不处理USB存储设备         * @param device         */        @Override        public void onDettach(final UsbDevice device) {            if (device == null)                //先停止录视频，否则生成视频无法播放                return;            if (isUsbDevAUvcCamera(device)) {                mCurrentActivity.finish();            }        }        @Override        public void onCancel() {            enableViewListener.enableView(true);            if (pictureSocket != null) {                pictureSocket.tryGet().close();                pictureSocket = null;            }            if (optionSocket != null) {                optionSocket.tryGet().close();                optionSocket = null;            }        }    };    //初始化摄像头    public void initializeCamera(CameraClient cameraClient) {        FileUtils.writeFileToLogFolder("初始化摄像头");        // TODO: 2016/7/10  : 添加默认参数配置 :        //setConfigurationParameter();        msetConigurationParameter();        //Object objBrightness = SPUtils.get(mCurrentActivity, "brightness", 0);        int defBrightness = cameraClient.getBrightness();        //Object objContrast = SPUtils.get(mCurrentActivity, "contrast", 0);        // int defContrast = objContrast==null?OBJECTIVES[0]:(int)objContrast;        int defContrast = BaseApplication.getInstance().getContrast();        //Object objGain = SPUtils.get(mCurrentActivity, "gain", 0);        int defGain = cameraClient.getGain();        // Object objSaturation = SPUtils.get(mCurrentActivity, "saturation", 0);        int defSaturation = cameraClient.getSaturation();        // Object objFocus = SPUtils.get(mCurrentActivity, "focus", 0);        //int defFocus = cameraClient.getFocus();        if (defBrightness > 0) {            if (isSetBrightness) {                isSetBrightness = false;                cameraClient.setBrightness(defBrightness);            }        }        if (defContrast > 0) {            //20170427 更改只有开机才初始化放大物镜            if (isSetContrast) {                isSetContrast = false;                cameraClient.setContrast(defContrast);            }        }        if (defGain > 0)            cameraClient.setGain(defGain);        if (defSaturation > 0) {            // Object autoPhoto_views = SPUtils.get(getBaseContext(), "autoPhoto_views", 0);            // int isautoRename =autoPhoto_views==null?1: (int) autoPhoto_views;            if (BaseApplication.getInstance().getAutoPhoto_views() == 3) {//如果正在自动拍照则不打开灯            } else {                if (issetSaturation) {                    issetSaturation = false;                    cameraClient.setSaturation(defSaturation);                }            }        }        // if (defFocus > 0)        //    cameraClient.setGamma(defFocus);        //从SharePreference读取记录的 着色设置值 :        //Object objColor = SPUtils.get(mCurrentActivity, "recolor", 0);        //int defColor = (objColor != null) ? (int) objColor : 0;        int defColor = BaseApplication.getInstance().getRecolor();        if (defColor != 0) {            cameraClient.clientColor(defColor);        }        cameraClient.setAutoFocus(false);        enableViewListener.enableView(true);        if (pictureSocket != null)            if (pictureSocket.tryGet() != null)                pictureSocket.tryGet().close();        displayPictureByWebSocket();        if (optionSocket != null)            if (optionSocket.tryGet() != null)                optionSocket.tryGet().close();        cameraOptionByWebSocket();    }    public final BaseActivity.OnEnableViewListener enableViewListener = new BaseActivity.OnEnableViewListener() {        @Override        public void enableView(final boolean enable) {            if (DEBUG)                Logger.d(TAG, "enableViewListener = " + enable);            if (mCameraClient != null && mCameraClient.isRecording()) {                mCurrentActivity.runOnUiThread(new Runnable() {                    @Override                    public void run() {                    }                });            } else {                mCurrentActivity.runOnUiThread(new Runnable() {                    @Override                    public void run() {                    }                });            }        }    };    public void displayPictureByWebSocket() {        AsyncHttpClient.WebSocketConnectCallback connectCallback = new AsyncHttpClient.WebSocketConnectCallback() {            @Override            public void onCompleted(Exception ex, WebSocket webSocket) {                if (ex != null) {                    System.out.println("I got an error");                    ex.printStackTrace();                    pictureSocket = null;                    displayPictureByWebSocket();                    return;                }                webSocket.setDataCallback(new DataCallback() {                    @Override                    public void onDataAvailable(DataEmitter emitter, final ByteBufferList bb) {                    }                });                webSocket.setEndCallback(new CompletedCallback() {                    @Override                    public void onCompleted(Exception ex) {                        if (DEBUG)                            Logger.e(TAG, "I got an error");                        if (ex != null) {                            ex.printStackTrace();                            return;                        }                    }                });                webSocket.setClosedCallback(new CompletedCallback() {                    @Override                    public void onCompleted(Exception ex) {                        if (DEBUG)                            Logger.e(TAG, "I got an error");                        if (ex != null) {                            ex.printStackTrace();                            pictureSocket = null;                            displayPictureByWebSocket();                            return;                        }                    }                });            }        };        pictureSocket = AsyncHttpClient.getDefaultInstance().websocket(CustomWebSocketServer.PROTOCOL + CustomWebSocketServer.URI1 + SynchronousScreenChannel.CHANNEL_NAME, null, connectCallback);    }    private boolean selfCheckFlag = false;    private int delaySecond;    public synchronized void programSelfCheck() {        if (!selfCheckFlag) {            if (ConstantUtil.is_recoding) {                MasterIntentService.this.record();                FileUtils.writeFileToLogFolder("自检程序停止录制视频 selfCheckFlag=" + selfCheckFlag);            }            if (!ConstantUtil.isAutoFocusFinish) {                mMasterActivityBinder.stopAutoFocus();                FileUtils.writeFileToLogFolder("自检程序停止自动对焦 selfCheckFlag=" + selfCheckFlag);            }        } else {            int checknumb;            Random random = new Random();            if (ConstantUtil.unDisplay) {                checknumb = 8;            } else {                checknumb = 9;            }            int check = random.nextInt(checknumb);            if (!ConstantUtil.isAutoFocusFinish) {                check = 4;//如果上个指令是自动对焦，就先停止自动对焦            } else if (ConstantUtil.is_recoding) {                check = 5;//如果上个指令是录制视频，先保存视频            }            Log.w(TAG, "programSelfCheck check=" + check + "  selfCheckFlag=" + selfCheckFlag);            switch (check) {                case 0://调节ISO                    delaySecond = 10;                    int gain = random.nextInt(5);                    int gains[] = {0, 16, 32, 64, 80, 100};                    int maxiso = mMasterActivityBinder.getMaxNuberType(2);                    int mgain = gains[gain];                    if (mgain > maxiso) {                        mgain = maxiso;                    }                    FileUtils.writeFileToLogFolder("check=" + check + " 自检程序调节ISO：gain=" + mgain);                    Log.w(TAG, "ISO  gains[gain]=" + mgain);                    BaseApplication.getInstance().setGain(mgain);                    if (mMasterActivityShowHandler != null) {                        mMasterActivityShowHandler.sendMessageDelayed(mMasterActivityShowHandler.obtainMessage(EXECUTE_ISO_CAMMAND, mgain, 0), 100);                    }                    mPutConfigurationParameter();                    break;                case 1://调节MF                    delaySecond = 10;                    int gamma = random.nextInt(5);                    int gammas[] = {2, 64, 1024, -2, -64, 1024};                    Log.w(TAG, "MF  gammas[gamma]=" + gammas[gamma]);                    if (gammas[gamma] > 0) {                        FileUtils.writeFileToLogFolder("check=" + check + "  自检程序向上对焦： gamma=" + gammas[gamma]);                        setClientGamma(gammas[gamma]);                    } else {                        FileUtils.writeFileToLogFolder("check=" + check + "  自检程序向下对焦： gamma=" + (-gammas[gamma]));                        setDownClientGamma(gammas[gamma]);                    }                    break;                case 2://调节Brightness                    delaySecond = 10;                    int brightness = random.nextInt(6);                    int mbrightness[] = {-1, -50, -1000, 1, 50, 1000};                    int brightness1 = BaseApplication.getInstance().getBrightness();                    Log.w(TAG, "Brightness  brightness=" + brightness1 + mbrightness[brightness]);                    FileUtils.writeFileToLogFolder("check=" + check + "  自检程序调节亮度： brightness=" + (brightness1 + mbrightness[brightness]));                    int currentb = brightness1 + mbrightness[brightness];                    int maxBrighness = mMasterActivityBinder.getMaxBrighness();                    if (currentb > maxBrighness) {                        currentb = maxBrighness;                    }                    //1920  972                    if (currentb < 0) {                        currentb = 0;                    }                    BaseApplication.getInstance().setBrightness(currentb);                    if (mMasterActivityShowHandler != null) {                        mMasterActivityShowHandler.sendMessageDelayed(mMasterActivityShowHandler.obtainMessage(EXECUTE_BRIGHTNESS_CAMMAND, currentb, 0), 100);                    }                    mPutConfigurationParameter();                    break;                case 3://自动对焦                    delaySecond = 10;                    FileUtils.writeFileToLogFolder("check=" + check + "  自检程序自动对焦");                    MasterIntentService.this.setScaleValueXY(UVCCamera.DEFAULT_PREVIEW_WIDTH / 2, UVCCamera.DEFAULT_PREVIEW_WIDTH / 2);                    MasterIntentService.this.startAutoFocus();                    break;                case 4://停止自动对焦                    delaySecond = 1;                    ConstantUtil.isAutoFocusFinish = true;                    mMasterActivityBinder.stopAutoFocus();                    FileUtils.writeFileToLogFolder("check=" + check + "  自检程序停止自动对焦");                    break;                case 5://录制视频                    delaySecond = 35;                    if (!ConstantUtil.isAllowOperation)                        return;                    if (ConstantUtil.is_recoding) {                        MasterIntentService.this.record();                        FileUtils.writeFileToLogFolder("check=" + check + "  自检程序停止录制视频");                    } else {                        float fileSize = FileUtil.externalSDSize(getApplicationContext());                        if (fileSize < 0.5)                            return;                        MasterIntentService.this.record();                        FileUtils.writeFileToLogFolder("check=" + check + "  自检程序录制视频");                    }                    break;                case 6://拍照                    delaySecond = 10;                    float fileSize = FileUtil.externalSDSize(getApplicationContext());                    if (fileSize < 0.5)                        return;                    setCilentCapture();                    FileUtils.writeFileToLogFolder("check=" + check + "  自检程序拍照");                    break;                case 7://切换激发快                    delaySecond = 10;                    int saturation;                    saturation = random.nextInt(ConstantUtil.LIGHTSCOUNT + 1);                    setClientSaturation(saturation);                    FileUtils.writeFileToLogFolder("check=" + check + "  自检程序切换激发快");                    break;                case 8://切换物镜                    delaySecond = 7;                    mMasterActivityBinder.changeContrastState();                    FileUtils.writeFileToLogFolder("check=" + check + " 自检程序切换物镜");                    break;            }            mMasterActivityShowHandler.sendEmptyMessageDelayed(MasterActivity.UPDATE_AUTO_SELF_CHECK, delaySecond * 1000);        }    }    //接收手机控制端发送信息    public void cameraOptionByWebSocket() {        AsyncHttpClient.WebSocketConnectCallback connectCallback = new AsyncHttpClient.WebSocketConnectCallback() {            final int CAPTURE = 0;            final int CAPTURE_STILL = 1;            final int PARAM_TYPE_SATURATION = 2;            final int PARAM_TYPE_CONTRAST = 3;            final int COLORS = 4;            final int RECOLORS_STRING = 24;            final int PARAM_TYPE_ISO = 5;            final int PARAM_TYPE_BRIGHTNESS = 6;            final int SHUT_DOWN = 7;            final int PARAM_TYPE_MANUAL_FOCUS = 8;            final int PARAM_TYPE_GAMMA = 9;            final int PARAM_TYPE_GAMMA_DOMN = 19;            final int PARAM_TYPE_MANUAL_FOCUS_STOP = 10;            final int PARAM_TYPE_VESSELS = 14;            final int PARAM_TYPE_UpDATE_PICTER = 15;//更新右下角缩略图            final int PARAM_TYPE_AUTOPHOTO = 16;//自动拍照            final int PARAM_TYPE_STOPAUTOPHOTO = 17;//停止自动拍照            final int PARAM_TYPE_AUTOPHOTOPREPARE = 28;//准备自动拍照            final int PARAM_TYPE_CONSTAST = 29;//对照组定位设定            final int PARAM_TYPE_ROCKERVIEW = 30;//摇杆控制            final int PARAM_TYPE_SELF_CHECK = 31;//开启关闭自检程序            final int PARAM_TYPE_EXPORT = 32;//导出文件到U盘            @Override            public void onCompleted(Exception ex, final WebSocket webSocket) {                if (ex != null) {                    System.out.println("I got an error");                    ex.printStackTrace();                    optionSocket = null;                    cameraOptionByWebSocket();                    return;                }                webSocket.setDataCallback(new DataCallback() {                    @Override                    public void onDataAvailable(DataEmitter emitter, ByteBufferList bb) {                        System.out.println("I got some bytes ! ");                        //在此处处理数据 :                        //数据处理完后,回收缓冲区 :                        //                        bb.recycle();                    }                });                /**                 * {                 *     "type":0,(0,拍摄；1，摄影；2，荧光灯；3，虚拟焦距)                 *     "param":                 *     a.拍摄:0(完成)；                 *     b.摄影：0，1(完成)；                 *     c.荧光灯：0，1，2，3(完成)；                 *     d.虚拟焦距：0，10，20，30(完成);                 *     e.颜色渲染：0~120(完成)                 *     f.ISO:0-100(完成)                 *     e.亮度:0-100(完成)                 *     g.关机                 *     h.手动对焦                 * }                 */                webSocket.setStringCallback(new WebSocket.StringCallback() {                    @Override                    public void onStringAvailable(String s) {                        if (DEBUG)                            Logger.e(s);                        JSONObject json = null;                        try {                            Log.e("jsontest", "json=" + s);                            json = JSON.parseObject(s);                        } catch (Exception e) {                            e.printStackTrace();                            return;                        }                        int type = json.getInteger("type");     //获取手机端发送过来的JSON的类型 ;                        if (type == 300) {                            mloginCallback.loginState(true);                        }                        final int param = json.getInteger("param");     //获取手机端发送过来的type类型的数值 ;                        if (mCameraClient != null) {                            switch (type) {                                // OK                                case CAPTURE:       //手机端遥控平板拍照 :                                    FileUtils.writeFileToLogFolder("局域网控制拍照");                                    setCilentCapture();                                    break;                                // OK                                case RECOLORS_STRING:                                    String recolorstring = json.getString("recolorstring");                                    FileUtils.writeFileToLogFolder("局域网控制着色：recolorstring=" + recolorstring);                                    if (!recolorstring.equals("")) {                                        BaseApplication.getInstance().setCurrentReColorString(recolorstring.trim());                                        //BaseApplication.getInstance().setCurrentSaturationString(recolorstring.trim());                                        if (mCameraClient != null)                                            mCameraClient.setRecolorString(recolorstring);                                    }                                    break;                                case CAPTURE_STILL:     //手机端遥控平板录像 :                                    if (!ConstantUtil.isAutoPhotoFinish) {                                        // UIUtil.toast(activity, "请停止自动拍照后再录制视频 ! ", true);                                        return;                                    }                                    if (ConstantUtil.isFastDoubleClick()) {                                        return;                                    }                                    FileUtils.writeFileToLogFolder("局域网遥控平板录像");                                    MasterIntentService.this.record();                                    break;                                // OK                                case PARAM_TYPE_SATURATION:     //从手机端获取数据设置激发块灯光 :                                    FileUtils.writeFileToLogFolder("局域网遥控平板设置激发块灯光：saturation=" + param);                                    setClientSaturation(param);                                    break;                                // OK                                case PARAM_TYPE_CONTRAST:       //手机端遥控平板切换物镜 :                                    FileUtils.writeFileToLogFolder("局域网遥控平板切换物镜：constrast=" + param);                                    setClientConstrast(param);                                    break;                                // OK                                //激发块 灯光着色选择 :                                case COLORS:        //手机端遥控平板着色 :                                    FileUtils.writeFileToLogFolder("局域网遥控平板着色：recolor=" + param);                                    BaseApplication.getInstance().setRecolor(param);                                    // String mrecolorstring= json.getString("recolorstring");                                    // Log.e("MasterIntentService","recolorstring="+recolorstring);                                    /*if(!mrecolorstring.equals("")){                                        BaseApplication.getInstance().setCurrentSaturationString(mrecolorstring);                                        if(mCameraClient!=null)                                            mCameraClient.setRecolorString(mrecolorstring);                                    }*/                                    // Log.i("test", "MasterIntentService cameraOptionByWebSocket() COLORS recolor = " + param + " === ");                                    //2016.08.02 : 新增 : 用于保存从手机端改变着色时配合默认参数设置的设置 :                                    webSocketChangeReColorSetting(param);                                    changeClientColor(param);                                    mPutConfigurationParameter();                                    break;                                // OK                                case PARAM_TYPE_ISO:     //手机端遥控平板调节感光度 :                                    FileUtils.writeFileToLogFolder("局域网遥控平板调节感光度：gain=" + param);                                    BaseApplication.getInstance().setGain(param);                                    //mCameraClient.setGain(param);                                    if (mMasterActivityShowHandler != null) {                                        mMasterActivityShowHandler.sendMessageDelayed(mMasterActivityShowHandler.obtainMessage(EXECUTE_ISO_CAMMAND, param, 0), 100);                                    }                                    mPutConfigurationParameter();                                    break;                                case PARAM_TYPE_UpDATE_PICTER:                                    List<File> pngFiles = PictureUtils.getPicturesScaled(getApplicationContext());                                    if (pngFiles.size() > 0) {                                        Collections.reverse(pngFiles);  //Collections.reverse()反转集合中元素的顺序                                        Collections.sort(pngFiles, new MyFileComparator());                                        String picturename = pngFiles.get(0).getPath();                                        FileUtils.writeFileToLogFolder("局域网遥控平板更新缩略图：picturename=" + picturename);                                        if (mMasterActivityBinder != null) {                                            mMasterActivityBinder.uadateTPicterFileName(picturename);                                        }                                    }                                    break;                                case PARAM_TYPE_VESSELS:                                    ConstantUtil.CHECK_AUTOFOCUS = param;                                    if (mCameraClient != null)                                        mMasterActivityBinder.sendToBackgroundProgram("check_aotufocus_object", ConstantUtil.CHECK_AUTOFOCUS + "");                                    FileUtils.writeFileToLogFolder("局域网遥控平板选择自动对焦的器皿： ConstantUtil.CHECK_AUTOFOCUS=" + param);                                    break;                                case PARAM_TYPE_BRIGHTNESS:     //手机端遥控平板调节亮度 :                                    FileUtils.writeFileToLogFolder("局域网遥控平板调节亮度： brightness=" + param);                                    BaseApplication.getInstance().setBrightness(param);                                    if (mMasterActivityShowHandler != null) {                                        mMasterActivityShowHandler.sendMessageDelayed(mMasterActivityShowHandler.obtainMessage(EXECUTE_BRIGHTNESS_CAMMAND, param, 0), 100);                                    }                                    mPutConfigurationParameter();                                    break;                                case PARAM_TYPE_GAMMA:      //手机端遥控平板对焦 :                                   /* if(mMasterActivityBinder.getObjectiveSwithState(true)){                                        return;                                    }*/                                    FileUtils.writeFileToLogFolder("局域网遥控平板向上对焦： gamma=" + param);                                    setClientGamma(param);                                    break;                                case PARAM_TYPE_GAMMA_DOMN:                                    FileUtils.writeFileToLogFolder("局域网遥控平板向下对焦： gamma=" + param);                                    setDownClientGamma(param);                                    break;                                case SHUT_DOWN:         //手机端遥控平板关机 :                                    if (mCameraClient != null) {                                        mCameraClient.setSaturation(0);                                    }                                    FileUtils.writeFileToLogFolder("局域网遥控平板关机");                                    try {                                        Process process = Runtime.getRuntime().exec("su");                                        DataOutputStream out = new DataOutputStream(                                                process.getOutputStream());                                        out.writeBytes("reboot -p\n");                                        out.writeBytes("exit\n");                                        out.flush();                                    } catch (IOException e) {                                        e.printStackTrace();                                    }                                    break;                                case PARAM_TYPE_MANUAL_FOCUS:                                    if (ConstantUtil.isStartAutofocus) {                                        return;                                    }                                    final float mNewX = json.getFloat("x");                                    final float mNewY = json.getFloat("y");                                    FileUtils.writeFileToLogFolder("局域网遥控平板自动对焦：mNewX=" + mNewX + "  mNewY=" + mNewY);                                    MasterIntentService.this.setScaleValueXY(mNewX / 1360, mNewY / 1040);                                    MasterIntentService.this.startAutoFocus();                                    break;                                //2016.08.03 : 新增 : 手机端停止平板端的快速对焦和自动对焦 :                                case PARAM_TYPE_MANUAL_FOCUS_STOP:                                    //                                    SPUtils.put(mCurrentActivity, "focus", param);                                    //2016.08.03 : 修改 :     手机端停止平板端的快速对焦和自动对焦 :                                    // MasterIntentService.this.stopAllAutoFocus();                                    mMasterActivityBinder.stopAutoFocus();                                    FileUtils.writeFileToLogFolder("局域网遥控平板停止自动对焦");                                    break;                                case PARAM_TYPE_AUTOPHOTO:                                    FileUtils.writeFileToLogFolder("局域网遥控平板开始自动拍照：json=" + json.toString());                                    setClientAutoPhoto(json);                                    break;                                case PARAM_TYPE_STOPAUTOPHOTO:                                    FileUtils.writeFileToLogFolder("局域网遥控平板停止自动拍照");                                    mMasterActivityBinder.stopAutoPhoneTimer();                                    if (mMasterActivityShowHandler != null) {                                        mMasterActivityShowHandler.sendEmptyMessage(MasterActivity.SHOW_AUTO_PHONE_TIMER);                                    }                                    if (mMasterActivityBinder != null)                                        mMasterActivityBinder.sendToBackgroundProgram("autophotoview", "gone");                                    break;                                case PARAM_TYPE_AUTOPHOTOPREPARE:                                    if (mCameraClient != null)                                        mMasterActivityBinder.sendToBackgroundProgram("autophotoview", "prepare");                                    BaseApplication.getInstance().setAutoPhoto_views(2);                                    break;                                case PARAM_TYPE_CONSTAST:                                    String resultstr = json.getString("result");                                    FileUtils.writeFileToLogFolder("局域网遥控平板设定对照组位置：x=" + DataUtil.stateI + " y=" + DataUtil.stateII);                                    boolean checkstate = Boolean.parseBoolean(resultstr);                                    if (checkstate) {                                        DataUtil.moveSate[param][0] = DataUtil.stateI;                                        DataUtil.moveSate[param][1] = DataUtil.stateII;                                        DataUtil.CheckNums[param] = checkstate;                                    } else {                                        DataUtil.moveSate[param][0] = 0;                                        DataUtil.moveSate[param][1] = 0;                                        DataUtil.CheckNums[param] = checkstate;                                    }                                    if (mCameraClient != null)                                        mMasterActivityBinder.sendToBackgroundProgram(DataUtil.CONTRASTKEY, param + "&" + checkstate);                                    break;                                case PARAM_TYPE_ROCKERVIEW:                                    String command = json.getString("command");                                    if (DataUtil.isConnectBlue) {                                        BlueUtil.sendMessageHandle(command);                                    }                                    // Log.w(TAG, "command=" + command);                                    break;                                case PARAM_TYPE_SELF_CHECK://程序自检                                    if (selfCheckFlag) {                                        selfCheckFlag = false;                                        mMasterActivityShowHandler.removeMessages(MasterActivity.UPDATE_AUTO_SELF_CHECK);                                        UIUtil.toast(mMasterActivity, "已停止程序自检", true);                                    } else {                                        selfCheckFlag = true;                                        UIUtil.toast(mMasterActivity, "已开启程序自检", true);                                    }                                    programSelfCheck();                                    break;                                case PARAM_TYPE_EXPORT:                                    //param =1 为导出后删除                                    mMasterActivity.runOnUiThread(new Runnable() {                                        @Override                                        public void run() {                                            clientExportFile(param);                                        }                                    });                                    break;                            }                        }                    }                });                webSocket.setEndCallback(new CompletedCallback() {                    @Override                    public void onCompleted(Exception ex) {                        if (ex != null) {                            ex.printStackTrace();                            return;                        }                    }                });                webSocket.setClosedCallback(new CompletedCallback() {                    @Override                    public void onCompleted(Exception ex) {                        if (ex != null) {                            ex.printStackTrace();                            optionSocket = null;                            cameraOptionByWebSocket();                            return;                        }                    }                });            }        };        optionSocket = AsyncHttpClient.getDefaultInstance().websocket(CustomWebSocketServer.PROTOCOL + CustomWebSocketServer.URI2 + CameraOperationChannel.CHANNEL_NAME, null, connectCallback);    }    private void clientExportFile(int param) {        if (ConstantUtil.isFastDoubleClick()) {            return;        }        ExternalSD externalSD = new ExternalSD(mMasterActivity);        ExternalHDD externalHDD = new ExternalHDD(mMasterActivity);        File usbCard = externalHDD.getUSBCardPath();        // 20171013 v80plus 判断u盘插入方法        Log.w("MasterIntentService", "usbCard=" + usbCard.length());        long length = usbCard.length();        if (length < 41) {            UIUtil.toast(mMasterActivity, "没有检测到连接任何外界存储设备，请先连接", true);            return;        }       /*     //非v80plus判断u盘入方法            if ((sdcard_I == null || sdcard_I.length() == 0) && (usbCard == null || usbCard.length() == 0)) {                UIUtil.toast(mMasterActivity, "没有检测到连接任何外界存储设备，请先连接", true);                return;            }       */        if (ConstantUtil.isExport) {            UIUtil.toast(mMasterActivity, "正在导出，请等待！", false);            return;        }        if (mCameraClient != null)            mCameraClient.clientControl(CameraClient.CLIENT_NORMAL);        final File sdcard = externalSD.getSDCardDir();        final List<File> photoListFiles = PictureUtils.getPictures(getApplicationContext());        final List<File> photosScaled = PictureUtils.getPicturesScaled(getApplicationContext());        final List<File> photosScaledJpg = PictureUtils.getJpgPicturesScaled(getApplicationContext());        // Todo 视频文件导出操作（复制文件）        final List<File> videoListFiles = getMovies(getApplicationContext());        boolean isSDCard = false;        if (sdcard != null) {            if (sdcard.length() != 0)                isSDCard = true;        }        String mCurrentUserName = ConstantUtil.getCurrentUserName(getApplicationContext());        if (photoListFiles.size() + videoListFiles.size() == 0) {            UIUtil.toast(mMasterActivity, "指定文件夹中不存在需要导出的文件，请检查清楚", false);            ConstantUtil.savaCurrentUser(getApplicationContext(), mCurrentUserName);            return;        }        ConstantUtil.savaCurrentUser(getApplicationContext(), mCurrentUserName);        String exportUserName = ConstantUtil.EXPORT_USER_NAME;        File photoFile = new File(Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DCIM), exportUserName);        File videoFile = new File(Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_MOVIES), exportUserName);        long filesSize = FileSizeUtil.getFilesSizeInByte(photoFile.getPath());        filesSize += FileSizeUtil.getFilesSizeInByte(videoFile.getPath());        if (filesSize > FileUtil.getSDCardAllSize()) {            UIUtil.toast(mMasterActivity, "外置存储设备容量不足，请检查清楚", false);            return;        }        if (mCameraClient != null)            mCameraClient.clientControl(CameraClient.CLIENT_STOP);        if (param == 1) {            FileUtils.writeFileToLogFolder("用户选择导出后删除文件");            Log.w("MasterIntentService", "用户选择导出后删除文件");            initExportFiles(photoListFiles, photosScaled, photosScaledJpg, videoListFiles, isSDCard, true);        } else {            Log.w("MasterIntentService", "用户选择导出文件");            initExportFiles(photoListFiles, photosScaled, photosScaledJpg, videoListFiles, isSDCard, false);        }    }    private void setClientAutoPhoto(JSONObject json) {        if (mCameraClient != null) {            if (mCameraClient.isRecording()) {                return;            }        }        if (ConstantUtil.isFastDoubleClick()) {            return;        }        //解析自动拍照参数        String autophotolights = json.getString("autophotolights");        String isAutufocus = json.getString("autofocus");        String isSynthetic = json.getString("synthetic");        String startTimer = json.getString("autophoto_starttimer");        String tTimer = json.getString("autophoto_ttimer");        String endTimer = json.getString("autophoto_endtimer");        String autophotostr = json.getString("autophoto_stopstr");        ConstantUtil.stopAutoPhotoStr = autophotostr;        String ConverGence = json.getString("convergence");        if (ConverGence != null)            ConstantUtil.ConvergenceNumber = ConverGence;        String autophotoNumb = json.getString("autophoto_count");        if (!autophotoNumb.equals("") || autophotoNumb != null) {            ConstantUtil.autoPhotoCount = Integer.valueOf(autophotoNumb);        }        BaseApplication.getInstance().setAutoPhoto_startTime(startTimer);        BaseApplication.getInstance().setAutoPhoto_tTime(tTimer);        BaseApplication.getInstance().setAutoPhoto_finishTime(endTimer);        if (isAutufocus.equals("true")) {            ConstantUtil.isAutofocus = true;        } else {            ConstantUtil.isAutofocus = false;        }        if (isSynthetic.equals("true")) {            ConstantUtil.isSynthetic = true;        } else {            ConstantUtil.isSynthetic = false;        }        String[] strings = autophotolights.split("&");        Set<String> checkboxs = new HashSet<String>();        for (int i = 0; i < strings.length; i++) {            checkboxs.add(strings[i]);        }        SharedPreferences preferences = getApplicationContext().getSharedPreferences(ConstantUtil.CHECKBOXSTATE, 0);        SharedPreferences.Editor edit = preferences.edit();        edit.putStringSet(ConstantUtil.CHECKBOXS, checkboxs);        edit.commit();        //开始自动拍照        mMasterActivityBinder.startAutoPhoneTimer();        if (mMasterActivityShowHandler != null) {            mMasterActivityShowHandler.sendEmptyMessage(MasterActivity.SHOW_MAUTO_PHONE_TIMER);        }        if (mMasterActivityBinder != null)            mMasterActivityBinder.sendToBackgroundProgram("autophotoview", "visible");    }    //2016.08.02 : 新增 : 用于保存从手机端改变着色时配合默认参数设置的设置 :    private void webSocketChangeReColorSetting(int color) {        //获取当前选择的物镜倍数 :        int mul = BaseApplication.getInstance().getContrast();        //获取当前选择的激发块 :        int saturation = BaseApplication.getInstance().getSaturation();        //2016.07.18 新增 : 用sharepreference保存和获取用户的着色设置 :        String userRecolorString = "";        int defaultRecolor = MasterIntentService.RECOLOR_WHITE;        //默认着色 :        String multipleString = MasterIntentService.MULTIPLE_STRING_5X;        switch (mul) {            //5 x 倍物镜 :            case MasterIntentService.MULTIPLE_5X:                multipleString = MasterIntentService.MULTIPLE_STRING_5X;                break;            //10 x 倍物镜 :            case MasterIntentService.MULTIPLE_10X:                multipleString = MasterIntentService.MULTIPLE_STRING_10X;                break;            //20 x 倍物镜 :            case MasterIntentService.MULTIPLE_20X:                multipleString = MasterIntentService.MULTIPLE_STRING_20X;                break;            //40 x 倍物镜 :            case MasterIntentService.MULTIPLE_40X:                multipleString = MasterIntentService.MULTIPLE_STRING_40X;                break;            //50 x 倍物镜 :            case MasterIntentService.MULTIPLE_50X:                multipleString = MasterIntentService.MULTIPLE_STRING_50X;                break;        }        String saturationString = MasterIntentService.LIGHT_STRING_WHITE;        switch (saturation) {            //饱和灯光 颜色 : 白色            case MasterIntentService.LIGHT_SATURATION_WHITE:                saturationString = MasterIntentService.LIGHT_STRING_WHITE;                defaultRecolor = MasterIntentService.RECOLOR_WHITE;      //白着色 ;                break;            //饱和灯光 颜色 : 蓝色            case MasterIntentService.LIGHT_SATURATION_BLUE:                saturationString = MasterIntentService.LIGHT_STRING_BLUE;                defaultRecolor = MasterIntentService.RECOLOR_GREEN;      //绿着色 ;                break;            //饱和灯光 颜色 : 黑色            case MasterIntentService.LIGHT_SATURATION_BLACK:                saturationString = MasterIntentService.LIGHT_STRING_BLACK;                defaultRecolor = MasterIntentService.RECOLOR_WHITE;      //白着色 ;                break;            //饱和灯光 颜色 : 绿色            case MasterIntentService.LIGHT_SATURATION_GREEN:                saturationString = MasterIntentService.LIGHT_STRING_GREEN;                defaultRecolor = MasterIntentService.RECOLOR_RED;      //可选红/黄/橙 , 默认红着色 ;                break;            //2016.06.08 : 新增 :            //饱和灯光 颜色 : 紫色            case MasterIntentService.LIGHT_SATURATION_PURPLE:                saturationString = MasterIntentService.LIGHT_STRING_PURPLE;                defaultRecolor = MasterIntentService.RECOLOR_BLUE;      //蓝着色 ;                break;        }        userRecolorString = multipleString + saturationString;        //设置recolor着色值 :        SPUtils.put(mCurrentActivity, userRecolorString, color);    }    //主界面的 相机拍照 方法 :    public void capture() {        if (mMasterActivityShowHandler != null) {            //创建信息 :            Message msg = new Message();            msg.what = MasterActivity.SHOW_CAPTURE_VIEW;            Bundle bundle = new Bundle();            bundle.putBoolean(MasterActivity.START_CAPTURE, true);            msg.setData(bundle);            //向新线程中的Handler发送消息 ;            mMasterActivityShowHandler.sendMessage(msg);        }        if (mCameraClient != null) {            //2016.11.25 : 拍照照片名字 添加 : 物镜倍数 , 激发光 , ISO , 亮度,着色            //2016-11-25-11-16-37-10x-BlueLight-ISO200-Brightness2000-NO-Color.bmp            //获取当前选择的物镜倍数 :            int mul = BaseApplication.getInstance().getContrast();            String reColorString = BaseApplication.getInstance().getCurrentReColorString();            //获取当前的ISO增益 : gain :            int sensitivity = BaseApplication.getInstance().getGain();            //更正ISO在文件名中记录值            switch (sensitivity) {                case 0:                    sensitivity = 100;                    break;                case 16:                    sensitivity = 200;                    break;                case 32:                    sensitivity = 400;                    break;                case 48:                    sensitivity = 800;                    break;                case 64:                    sensitivity = 1600;                    break;                case 80:                    sensitivity = 3200;                    break;                case 100:                    sensitivity = 6400;                    break;            }            //获取当前的亮度值 : brightness :            int brightness = BaseApplication.getInstance().getBrightness();            //增加名字后缀            String nameSuffix = "-" + mul + "x-" + ConstantUtil.SaturationString + "-ISO" + sensitivity + "-B" + brightness + "-" + reColorString;            /*            * 20170815 更改为分别存储为三个文件目录下：big、 request 、scale            *            * */            //String path = MediaMuxerWrapper.getCaptureFile(Environment.DIRECTORY_DCIM, nameSuffix + ".bmp").toString();            String timerstr = MDateUtils.getDateTimeString();            timerstr = MDateUtils.numberString(ConstantUtil.filenumber, BaseApplication.getInstance().getSaturation()) + "-" + timerstr;            String path = MediaMuxerWrapper.getCaptureFile(Environment.DIRECTORY_DCIM, timerstr + nameSuffix + ".bmp", "big").toString();            String pathrequest = MediaMuxerWrapper.getCaptureFile(Environment.DIRECTORY_DCIM, timerstr + nameSuffix + ".bmp", "request").toString();            String pathscale = MediaMuxerWrapper.getCaptureFile(Environment.DIRECTORY_DCIM, timerstr + nameSuffix + ".bmp", "scale").toString();            //记录当前拍照名称            ConstantUtil.currentCaptureName = pathscale;            mCameraClient.capture(path, pathrequest, pathscale);            //mCameraClient.capture(pathrequest);            //mCameraClient.capture(pathscale);        }        if (mMasterActivityShowHandler != null) {            //创建信息 :            Message msg = new Message();            msg.what = MasterActivity.SHOW_CAPTURE_VIEW;            Bundle bundle = new Bundle();            bundle.putBoolean(MasterActivity.FINISH_CAPTURE, true);            msg.setData(bundle);            //向新线程中的Handler发送消息 ;            mMasterActivityShowHandler.sendMessage(msg);        }    }    /**     * 录制视频     */    public void record() {        if (ConstantUtil.isSaveMovis) {            return;        }        String currentUserName = ConstantUtil.getCurrentUserName(getApplicationContext());        BaseApplication.DIR_NAME = currentUserName;        if (mCameraClient != null) {            if (mCameraClient.isRecording()) {                stopRecordingMethod();            } else {                mCameraClient.startRecording(ConstantUtil.filenumber);                if (mMasterActivityShowHandler != null) {                    //创建信息 :                    Message msg = new Message();                    msg.what = MasterActivity.SHOW_RECORD_VIEW;                    Bundle bundle = new Bundle();                    bundle.putBoolean(MasterActivity.START_RECORD, true);                    msg.setData(bundle);                    //向新线程中的Handler发送消息 ;                    mMasterActivityShowHandler.sendMessage(msg);                }            }        } else            mCurrentActivity.runOnUiThread(new Runnable() {                @Override                public void run() {                    UIUtil.toast(mCurrentActivity, "Please connect camera!!!", true);                }            });    }    private void stopRecordingMethod() {        mCameraClient.stopRecording();        if (mMasterActivityShowHandler != null) {            //创建信息 :            Message msg = new Message();            msg.what = MasterActivity.SHOW_RECORD_VIEW;            Bundle bundle = new Bundle();            bundle.putBoolean(MasterActivity.FINISH_RECORD, true);            //2016.07.08 : 新增 : 添加兼容测试功能的对话框判断 :            bundle.putBoolean(MasterActivity.IS_SELF_CKECK, isSelfCheckFlag);            msg.setData(bundle);            //向新线程中的Handler发送消息 ;            mMasterActivityShowHandler.sendMessage(msg);        }        EXECUTOR_SERVICE_SCHEDULED.schedule(new Runnable() {            @Override            public void run() {                recordSuccess();            }        }, 2000, TimeUnit.MILLISECONDS);    }    /**     * by wancy     * 通过视频文件判断录像是否成功     * 使用MediaExtractor读取视频流Sample信息。     *     * @return     */    private boolean recordSuccess() {        SharedPreferences sharedPreferences = getApplicationContext().getSharedPreferences(ConstantUtil.CURRENT_USER_SHAR_DIR, 0);        String DIR_NAME = sharedPreferences.getString(ConstantUtil.CURRENT__USER_SHAR, null);        File file = new File(Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_MOVIES), DIR_NAME);        File[] allfiles = file.listFiles();        if (allfiles == null) {            return false;        }        ByteBuffer buf = ByteBuffer.allocate(1024 * 500);        boolean ret = true;        //        MediaExtractor extractor = new MediaExtractor();    //多媒体 提取器        for (int k = 0; k < allfiles.length; k++) {            final File fi = allfiles[k];            if (fi.isFile()) {                if (fi.getPath().endsWith(".mp4")) {                    /**                     * MediaMuxer类主要用于将音频和视频数据进行混合生成多媒体文件（如：mp4文件）;                     * MediaExtractor则刚好相反，主要用于多媒体文件的音视频数据的分离。                     *                     * 使用MediaExtractor和MediaMuxer类来完成mp4文件的提取和生成，                     *                     * 非Android SDK内置的MP4读写相关的库，常用的有：ffmpeg，mp4v2，mp4parser等，                     * 可以用于兼容Android 4.3以下无法使用最新Android API的应用。                     *                     */                    MediaExtractor extractor = new MediaExtractor();    //多媒体 提取器                    //                    Log.i("test", "fi.getPath() = " + fi.getPath());                    try {                        extractor.setDataSource(fi.getPath());                    } catch (IOException ioe) {                        FileUtils.writeFileToLogFolder("================" + "录制视频IO异常" + " e=" + ioe + "======================");                        ioe.printStackTrace();                        //                                                Log.i("test", "拍摄失败 IOException  --- -- " + fi.getPath());                        fi.delete(); //删除失败的视频                        ret = false;                        extractor.release();                        continue;                    }                    //----------------------------------------------                    /**                     * 通过下面的代码块，来获取码流的详细信息，如：MimeType，分辨率、编码格式、码率、帧率等等。                     */                    int iVideoTrackIndex = -1;      //视频 数据通道索引                    int iAudioTrackIndex = -1;      //音频 数据通道索引                    //                    Log.i("test", "extractor.getTrackCount() = " + extractor.getTrackCount());                    for (int i = 0; i < extractor.getTrackCount(); i++) {                        //获取码流的详细格式/配置信息 ;                        MediaFormat format = extractor.getTrackFormat(i);                        if (format == null) {                            break;                        }                        String mime = format.getString(MediaFormat.KEY_MIME);                        if (mime.startsWith("video/")) {                            iVideoTrackIndex = i;                        } else if (mime.startsWith("audio/")) {                            iAudioTrackIndex = i;                        }                        //                        Log.i("test", "String mime = " + mime);                    }                    if (iVideoTrackIndex == -1 || iAudioTrackIndex == -1) {                        //                        Log.i("test", "拍摄失败 iVideoTrackIndex = " + iVideoTrackIndex + " , iAudioTrackIndex = " + iAudioTrackIndex + " --- -- ");                        ret = false;                        extractor.release();                        fi.delete();                        continue;                    }                    //                    Log.i("test", " iVideoTrackIndex = " + iVideoTrackIndex + " , iAudioTrackIndex = " + iAudioTrackIndex + " --- -- ");                    //获取到媒体文件的纤细信息之后 ,选择指定的通道 , 并分离和读取数据 :                    extractor.selectTrack(iVideoTrackIndex);    //选择读取视频数据 ;                    //Read first sample                    int sampleSize = extractor.readSampleData(buf, 0);  //读取一帧数据 ;                    if (sampleSize <= 0) {                        //                        Log.i("test", "拍摄失败 sample size: No sample  --- -- ");                        ret = false;                        fi.delete();                        break;                    }                    buf.clear();                    extractor.advance();  //移动到下一帧 ;                    //                    Log.i("test", "拍摄成功 sample size: " + sampleSize);                    extractor.release();    //读取结束后 , 要记得释放资源 ;                }            }        }        String resultString = "";        if (ret) {            //                            Toast.makeText(mCurrentActivity, "视频拍摄成功，请在相册中查看", Toast.LENGTH_SHORT).show();            resultString = "视频拍摄成功，请在相册中查看";        } else {            //                            Toast.makeText(mCurrentActivity, "视频拍摄失败", Toast.LENGTH_SHORT).show();            resultString = "视频拍摄失败";        }        if (mMasterActivityShowHandler != null) {            //创建信息 :            Message msg = new Message();            msg.what = MasterActivity.SHOW_RECORD_VIEW;            Bundle bundle = new Bundle();            bundle.putBoolean(MasterActivity.RECORD_SUCCESS, true);            bundle.putString(MasterActivity.RECORD_RESULT, resultString);            //2016.07.08 : 新增 : 添加兼容测试功能的对话框判断 :            bundle.putBoolean(MasterActivity.IS_SELF_CKECK, isSelfCheckFlag);            msg.setData(bundle);            //向新线程中的Handler发送消息 ;            mMasterActivityShowHandler.sendMessage(msg);        }        return ret;    }    public static List<File> getPictures(Context context) {        String currentUserName = ConstantUtil.getCurrentUserName(context);        List<File> list = new ArrayList<>();        File file = new File(Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DCIM), currentUserName);        File[] allFiles = file.listFiles();        if (allFiles == null) {            return list;        }        for (int k = 0; k < allFiles.length; k++) {            final File fi = allFiles[k];            if (fi.isFile()) {                int idx = fi.getPath().lastIndexOf(".");                if (idx <= 0) {                    continue;                }                String suffix = fi.getPath().substring(idx);                if (suffix.toLowerCase().equals(".jpg") ||                        suffix.toLowerCase().equals(".jpeg") ||                        suffix.toLowerCase().equals(".bmp") ||                        suffix.toLowerCase().equals(".png") ||                        suffix.toLowerCase().equals(".gif")) {                    list.add(fi);                }            }        }        return list;    }    public List<File> getMovies(Context context) {        String currentUserName = ConstantUtil.getCurrentUserName(context);        List<File> list = new ArrayList<>();        File file = new File(Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_MOVIES), currentUserName);        File[] allfiles = file.listFiles();        if (allfiles == null) {            return list;        }        for (int k = 0; k < allfiles.length; k++) {            final File fi = allfiles[k];            if (fi.isFile()) {                int idx = fi.getPath().lastIndexOf(".");                if (idx <= 0) {                    continue;                }                String suffix = fi.getPath().substring(idx);                if (suffix.toLowerCase().equals(".mp4")) {                    list.add(fi);                }            }        }        return list;    }    private Dialog dialog;    private File extendCard = null;    /**     * 导出文件优先U盘     *     * @param photoListFiles     * @param videoListFiles     * @param isSDCard     */    // private  long  allfilesize=0;    // private  long  firstfilesize=0;    public void initExportFiles(final List<File> photoListFiles, final List<File> photoScaled, final List<File> photoScaledJpg, final List<File> videoListFiles, boolean isSDCard, final boolean isDelete) {        // 初始化对话框        dialog = new Dialog(mMasterActivity, R.style.Dialog_Radio);        dialog.setContentView(R.layout.dialog_export_toast);        dialog.setCancelable(false);        dialog.setCanceledOnTouchOutside(false);        final TextView indexView = (TextView) dialog.findViewById(R.id.label_index);        TextView countView = (TextView) dialog.findViewById(R.id.label_count);        int countSize = photoListFiles.size() + videoListFiles.size();        countView.setText(String.valueOf(countSize));        if (mCameraClient != null) {            ConstantUtil.isExport = true;            mCameraClient.sendToBackgroundProgram("isexport", "istrue");        }        Log.w("MasterIntentService", "正在导出");        dialog.show();        // Todo 图片文件导出操作（复制文件并源文件）        final String timeText = MediaMuxerWrapper.getDateTimeString();        //2016.12.30 添加读写外置存储设备的权限检查 :        if (isSDCard) {            ExternalSD externalSD = new ExternalSD(mMasterActivity);            extendCard = externalSD.getSDCardAppDir(timeText);        } else {            ExternalHDD externalHDD = new ExternalHDD(mMasterActivity);            extendCard = externalHDD.getUSBAppPath(timeText);            // Log.w(TAG, "is USB HDD");        }        EXECUTOR_SERVICE.execute(new Runnable() {            @Override            public void run() {                int photoSize = photoListFiles.size();                for (int i = 0; i < photoSize; i++) {                    // 获取要复制的源文件                    File originFile = photoListFiles.get(i);                    // 复制文件到指定文件夹                    final int j = i + 1;                    mCurrentActivity.runOnUiThread(new Runnable() {                        @Override                        public void run() {                            indexView.setText(String.valueOf(j));                        }                    });                    if (com.yeespec.microscope.master.service.system.disk.FileUtils.CopySdcardFile(originFile.getAbsolutePath(), extendCard.getAbsolutePath() + "/" + originFile.getName()) == -1) {                        if (mCameraClient != null) {                            ConstantUtil.isExport = false;                            mCameraClient.sendToBackgroundProgram("isexport", "isflase");                        }                        dialog.dismiss();                        dialog = null;                        UIUtil.toast(mMasterActivity, "导出失败", true);                        return;                    }                }                // Todo 视频文件导出操作（复制文件并删除源文件）                int videoSize = videoListFiles.size();                for (int i = 0; i < videoSize; i++) {                    // 获取要复制的源文件                    File originFile = videoListFiles.get(i);                    final int j = i + 1 + photoSize;                    // 复制文件到指定文件夹                    mCurrentActivity.runOnUiThread(new Runnable() {                        @Override                        public void run() {                            indexView.setText(String.valueOf(j));                        }                    });                    if (com.yeespec.microscope.master.service.system.disk.FileUtils.CopySdcardFile(originFile.getAbsolutePath(), extendCard.getAbsolutePath() + "/" + originFile.getName()) == -1) {                        dialog.dismiss();                        dialog = null;                        if (mCameraClient != null) {                            ConstantUtil.isExport = false;                            mCameraClient.sendToBackgroundProgram("isexport", "isflase");                        }                        UIUtil.toast(mMasterIntentService, "导出失败", true);                        return;                    }                }                // 删除文件     2016.12.28 修改 ;                if (isDelete) {                    for (int i = 0; i < photoSize; i++) {                        // 获取要复制的源文件                        photoListFiles.get(i).delete();                        photoScaled.get(i).delete();                        photoScaledJpg.get(i).delete();                    }                    //删除视频源文件 :                    for (int i = 0; i < videoSize; i++) {                        // 获取要复制的源文件                        videoListFiles.get(i).delete();                    }                }                EXECUTOR_SERVICE_SCHEDULED.schedule(new Runnable() {                    @Override                    public void run() {                        //Log.w("MasterIntentService","lastfilesize="+FileUtil.getSDCardAllSize());                        mCurrentActivity.runOnUiThread(new Runnable() {                            @Override                            public void run() {                                // boolean externalStorageRemovable = Environment.isExternalStorageRemovable();                                // Log.w("MasterIntentService","isremove="+externalStorageRemovable);                                dialog.dismiss();                                dialog = null;                                if (mCameraClient != null) {                                    ConstantUtil.isExport = false;                                    mCameraClient.sendToBackgroundProgram("isexport", "isflase");                                }                                UIUtil.toast(mMasterIntentService, "导出成功", true);                            }                        });                    }                }, 15000, TimeUnit.MILLISECONDS);                if (mMasterActivityShowHandler != null) {                    //创建信息 :                    Message msg = new Message();                    msg.what = MasterActivity.SHOW_CAPTURE_VIEW;                    Bundle bundle = new Bundle();                    bundle.putBoolean(MasterActivity.FINISH_CAPTURE, true);                    msg.setData(bundle);                    //向新线程中的Handler发送消息 ;                    mMasterActivityShowHandler.sendMessage(msg);                }            }        });    }/*    private static long getFileSize(File file)  {        long size = 0;        if (file.exists()) {            FileInputStream fis = null;            try {                fis = new FileInputStream(file);                size = fis.available();            } catch (FileNotFoundException e) {                e.printStackTrace();            } catch (IOException e) {                e.printStackTrace();            }        } *//*else {            file.createNewFile();           // Log.e("获取文件大小", "文件不存在!");        }*//*        return size;    }*/    /**     * 2016.06.30 修改自动对焦 的对焦搜索逻辑 :      (将自动对焦搜索次数控制在 3个回合内停止 只要找到最大反差点 , 就要在下一个回合回到最大反差点附近然后停止) ;     * 一 . 判断镜头是否是处于最暗或最亮端 : (第一阶段)     *      如果是 , 对焦逻辑为往另一端一直跑 , 直到 mMinium最小灰度值 和 mMaximal最大灰度值 满足条件之前 , 不允许反转 !   ;     *              期间,一直采样和记录最大反差点 ;  允许反转后 , 反转回到该最大反差点 ;     (在两个回合内结束 !)     *      如果否 , 直接进入 第二阶段 ;     * 二 . 第二阶段 , 镜头处于相对良好的对焦位置 , 在原先的对焦算法上做修改 , (在最多三个回合内结束 !)     */    /**     * 2016.06.30 增加自动亮度调整 :    (增加灰度直方图统计数据 , 确定一个灰度阈值 , 将图像灰度二值化 , 统计黑白灰度的总数和比例)     * 根据采样到的 mBlackGrayScale 和 mWhiteGrayScale 来判断当前视场的亮度 :     * 一 . 如果mBlackGrayScale灰度统计值上升到总数的2/3以上 , 说明视场偏暗 :     * 动作 : 调节亮度值Brightness增加 , 直到mBlackGrayScale/mWhiteGrayScale的比例接近于 1 ;     * 二 . 如果mWhiteGrayScale灰度统计值上升到总数的2/3以上 , 说明视场偏亮 :     * 动作 : 调节亮度值Brightness减小 , 直到mBlackGrayScale/mWhiteGrayScale的比例接近于 1 ;     * (ISO值由默认参数设置操作里设置初始值 , 已经是选择了一个最适当的感光度值; 在自动亮度调整里不会轻易作变动 ,     * 只有当Brightness值增加到最大,而视场仍然偏暗时会加大ISO ;     * 或者当Brightness值增减小到最小,而视场仍然偏亮时会减小ISO ;     * <p/>     * 自动亮度调整 与 自动对焦绑定在一起 !     */    //2016.07.26 : 添加手动滑动对焦判断 :    // private boolean mManualAutoFocus = false;      //默认为false ; 只有手动滑动触发快速对焦时置为true,开始快速对焦 ;    //private static int MANUAL_AUTO_FOCUS_DELY = 8;    private Timer autoTimer;    private TimerTask autoTask;    private int countAutofocus;//第几次自动对焦    private int autoFocusDelayTimeCount;    private int resetGamaDelay = 3;    private int goupStepDelay = 2;    private boolean isStopAutofocus = true;    //开始自动对焦    public void startAutoFocus() {        // 20171013 v80pulus 判断U盘插入方法        ExternalHDD externalHDD = new ExternalHDD(mMasterActivity);        File usbCard = externalHDD.getUSBCardPath();        if (usbCard.length() > 40) {            UIUtil.toast(mMasterActivity, "请拨出U盘后再自动对焦", true);            return;        }        if (ConstantUtil.isAutoPhotoFinish == false) {            UIUtil.toast(mMasterActivity, "请先停止自动拍照后再自动对焦", false);            return;        }        if (CameraServerHandler.USE_USART) {            if (isStopAutofocus)                mMasterActivityShowHandler.removeMessages(MasterActivity.SHOW_AUTO_FOCUS_DATA);            mMasterActivityBinder.stopAutoFocus();            if (autoTask != null) {                autoTask = null;            }            startAutoFocusUSART(countAutofocus);        } else {        }    }    public void startAutoFocusUSART(final int count) {        EXECUTOR_SERVICE_SCHEDULED.schedule(new Runnable() {            @Override            public void run() {                isStopAutofocus = false;                ConstantUtil.isStartAutofocus = true;                ConstantUtil.isAutoFocusFinish = false;                autoFocusDelayTimeCount = 0;                mCameraClient.sendAutoFocusMessege(count, 0, 0, false, ConstantUtil.MOVE_SPEED);//停止自动对焦                mMasterActivityShowHandler.sendEmptyMessage(MasterActivity.SHOW_AUTO_FOCUS_DATA);                if (mMasterActivityShowHandler != null) {                    //创建信息 :                    Message msg = new Message();                    msg.what = MasterActivity.SHOW_AUTO_FOCUS_DATA;                    Bundle bundle = new Bundle();                    bundle.putString(MasterActivity.SHOW_FOCUS, "AUTO FOCUS->>");                    bundle.putString(MasterActivity.SHOW_FOCUS_VALUE, "");                    bundle.putString(MasterActivity.SHOW_GAMA_VALUE, "");                    msg.setData(bundle);                    //向新线程中的Handler发送消息 ;                    mMasterActivityShowHandler.sendMessage(msg);                }                int gamma = BaseApplication.getInstance().getGamma();                if (gamma < 1000 && gamma >= 0) {                    resetGamaDelay = 1;                } else if (gamma < 2000 && gamma > 1000) {                    resetGamaDelay = 2;                } else if (gamma < 3000 && gamma > 2000) {                    resetGamaDelay = 3;                } else if (gamma < 4000 && gamma > 3000) {                    resetGamaDelay = 5;                } else if (gamma > 4000) {                    resetGamaDelay = 6;                }                mMasterActivityBinder.getObjectiveSwithState(true);//开启串口动作完成限制                mCameraClient.mReleadFocus();//复位对焦电机                //重置gamma值                BaseApplication.getInstance().setGamma(0);                mCameraClient.getUartGamma(0);                EXECUTOR_SERVICE_SCHEDULED.schedule(new Runnable() {                    @Override                    public void run() {                        if (isStopAutofocus) {                            mMasterActivityShowHandler.sendEmptyMessage(MasterActivity.SHOW_AUTO_FOCUS_DATA);                            return;                        }                        //复位时开始初始化                        int up_step = ConstantUtil.CARRIER_STEP;                        switch (ConstantUtil.CHECK_AUTOFOCUS) {                            case 0:                                up_step = ConstantUtil.CARRIER_STEP;//默认选择是载玻片                                break;                            case 1:                                up_step = ConstantUtil.CARRIER_STEP;//载玻片                                break;                            case 2:                                up_step = ConstantUtil.PETRIDISH_STEP;//培养皿                                break;                            case 3:                                up_step = ConstantUtil.PLATE_STEP;//96孔板                                break;                        }                        int saturation = up_step;                        int gamma1 = BaseApplication.getInstance().getGamma();                        gamma1 += saturation;                        BaseApplication.getInstance().setGamma(gamma1);                        // mCameraClient.getUartGamma(gamma1);                        if (saturation > 0) {                            if (saturation < 1000 && saturation > 0) {                                goupStepDelay = 1;                            } else if (saturation < 2000 && saturation > 1000) {                                goupStepDelay = 2;                            } else if (saturation < 3000 && saturation > 2000) {                                goupStepDelay = 3;                            } else if (saturation < 4000 && saturation > 3000) {                                goupStepDelay = 4;                            } else {                                goupStepDelay = 5;                            }                            mMasterActivityBinder.getObjectiveSwithState(true);//开启串口动作完成限制                            mCameraClient.mSetGamma(saturation, true, -1, "09");//往上走stip步                        }                        autoTask = new TimerTask() {                            @Override                            public void run() {                                ConstantUtil.isStartAutofocus = false;                                autoFocusDelayTimeCount++;                                if (autoFocusDelayTimeCount == 1) {                                    int x = (int) (mScaleX * 1360);                                    int y = (int) (mScaleY * 1040);                                    //发送开始自动对焦                                    if (mCameraClient != null)                                        mCameraClient.sendAutoFocusMessege(count, x, y, true, ConstantUtil.MOVE_SPEED);                                    //  Log.e("MasterIntentService", "坐标" + x + ":" + y);                                }                                boolean autoFocusResult = false;                                if (mCameraClient != null)                                    autoFocusResult = mCameraClient.getAutoFocusResult();                                if (autoFocusResult) {//自动对焦成功                                    //设置gamma值 -1为只读取Gamma值                                    int uartGamma = mCameraClient.getUartGamma(-1);                                    BaseApplication.getInstance().setGamma(uartGamma);                                    cancel();                                    ConstantUtil.isAutoFocusFinish = true;                                    mMasterActivityShowHandler.sendEmptyMessage(MasterActivity.SHOW_AUTO_FOCUS_DATA);                                }                                if (autoFocusDelayTimeCount >= 120) {//时间到,停止自动对焦                                    //设置gamma值                                    int uartGamma = mCameraClient.getUartGamma(-1);                                    ConstantUtil.isAutoFocusFinish = true;                                    BaseApplication.getInstance().setGamma(uartGamma);                                    // SPUtils.put(getApplicationContext(), "mFocusMotorStatus", ConstantUtil.UARTGAMMA, true);                                    if (mCameraClient != null)                                        mCameraClient.sendAutoFocusMessege(count, 0, 0, false, ConstantUtil.MOVE_SPEED);//发送停止自动对焦指令                                    cancel();                                    mMasterActivityShowHandler.sendEmptyMessage(MasterActivity.SHOW_AUTO_FOCUS_DATA);                                }                            }                        };                        autoTimer = new Timer();                        autoTimer.schedule(autoTask, goupStepDelay * 1000, 1000);                    }                }, resetGamaDelay * 1000, TimeUnit.MILLISECONDS);            }        }, 0, TimeUnit.MILLISECONDS);    }    private final CameraViewInterface.Callback mCallback = new CameraViewInterface.Callback() {        @Override        public void onSurfaceCreated(final Surface surface) {            if (ConstantUtil.isAllowOperation)                tryOpenUVCCamera();            if (mCameraClient != null) {                //  Log.e(TAG, "MasterIntentService#onSurfaceCreated() surface =  " + surface);                if (mCameraView != null && mCameraView.getSurface() != null) {                }            }        }        @Override        public void onSurfaceChanged(final Surface surface, final int width, final int height) {            if (mCameraClient != null) {                //  Log.e(TAG, "MasterIntentService#onSurfaceChanged() surface =  " + surface);                if (mCameraView != null && mCameraView.getSurface() != null) {                    if (ConstantUtil.isAllowOperation)                        mCameraClient.addSurface(mCameraView.getSurface(), false);                }            }        }        @Override        public void onSurfaceDestroy(final Surface surface) {            if (mCameraClient != null) {                if (mCameraView != null && mCameraView.getSurface() != null && !isRunScreenSaver) {                    //  Log.e(TAG, "MasterIntentService#onSurfaceDestroy() surface =  " + surface);                    if (ConstantUtil.isAllowOperation) {                        mCameraClient.removeSurface(mCameraView.getSurface());                        mCameraClient.disconnect();                    }                }            }        }    };    private float mScaleX = 0;    private float mScaleY = 0;    /**     * 定时隐藏     */    //  public int mBrightness = -1;    //  private int mMaxGamma = 5000;    //数值滚转的阶段 :    // public int mStep = 1;    //定义一个标志位flag , 线程结束后置位 , 防止双击聚焦的线程多次重复激发    //public boolean mThreadFlag = true;    // private int mSum = 0;    //private int mAvg = 0;    //private int mStandardDeviation = 0;    //private int mArrayLength = 0;    /*private int mArrayLength1 = 0;    private int mMinium = 0;    private int mMaximal = 0;    private boolean mGammaFlag = false;    //标志位 : flag    private int mContrastFlag = 10;        //物镜倍数 ,初始化为10倍物镜    private int mSaturationFlag = 0;        //激发块选择标志 , 范围 : 0 ~ 3    private boolean mSelfCheckFlag = false;    //自检程序标志 , 初始化为false ; true为正在自检 ; 调用一次就切换一次 ;    private int mFlag5 = 0;*/    //对焦控制耐久测试 :    Timer gammaTimer;    //物镜切换控制耐久测试 :    Timer contrastTimer;    //物镜切换控制耐久测试 :    Timer saturationTimer;    //定时录像测试 :    Timer recordTimer;    //定时录像定时器 :    //录像延时定时器 :    //定时拍照测试 :    Timer phoneTimer;    //用于录像的定时器任务 :    //2016.07.08 新增 : 添加兼容测试功能的对话框判断的标识位 :    private boolean isSelfCheckFlag = false;    // private float[] mPixelsArrayBuffer = new float[mArrayLength];    /*public void stopFocus() {        if (mCameraClient != null) {            int currentGamma = mCameraClient.getGamma();            mCameraClient.setGamma(currentGamma / 2);            mCameraClient.setGamma(currentGamma / 2 + 1);        }    }*/    //开始自检程序 :    int startgamaTimerNum = 0;    int selfcheckSaturation = 1;    boolean isfirsSelfCheck = true;    public void startSelfCheck() {        startgamaTimerNum = 0;        selfcheckSaturation = 1;        stopSelfCheck();        //2016.07.08 : 新增 : 拍摄图像 标识位 :        isSelfCheckFlag = true;     //正在测试程序中 ;        //对焦控制耐久测试 :        gammaTimer = new Timer();        //物镜切换控制耐久测试 :        contrastTimer = new Timer();        //物镜切换控制耐久测试 :        saturationTimer = new Timer();        //定时录像测试 :        recordTimer = new Timer();        //定时拍照测试 :        phoneTimer = new Timer();        //切换物镜        if (isfirsSelfCheck) {            isfirsSelfCheck = false;        } else {            //Object objMultiple = SPUtils.get(getApplicationContext(), "contrast", 10);            //int multiple = (objMultiple == null ? 10 : (int) objMultiple);            int multiple = BaseApplication.getInstance().getContrast();            if (ConstantUtil.OBJECTIVES.length <= 0) {                return;            }            for (int i = 0; i < ConstantUtil.OBJECTIVES.length; i++) {                if (multiple == ConstantUtil.OBJECTIVES[i]) {                    if (i == ConstantUtil.OBJECTIVES.length - 1) {                        multiple = ConstantUtil.OBJECTIVES[0];                    } else {                        multiple = ConstantUtil.OBJECTIVES[i + 1];                    }                    break;                }            }            BaseApplication.getInstance().setContrast(multiple);            BaseApplication.getInstance().setCurrentContrast(multiple);            BaseApplication.getInstance().setCurrent_contrast(multiple);            if (mCameraClient != null) {                mMasterActivityBinder.getObjectiveSwithState(true);//开启串口动作完成限制                mCameraClient.setContrast(multiple);            }        }        //对焦自检 :打开白色灯        mMasterActivityBinder.getObjectiveSwithState(true);//开启串口动作完成限制        mMasterActivityBinder.setSaturation(selfcheckSaturation);        if (mMasterActivityShowHandler != null) {            //创建信息 :            Message msg = new Message();            msg.what = MasterActivity.UPDATE_AUTO_DISPLAY;            msg.arg1 = selfcheckSaturation;            //向新线程中的Handler发送消息 ;            mMasterActivityShowHandler.sendMessage(msg);        }        gammaTimer.scheduleAtFixedRate(new TimerTask() {            @Override            public void run() {                startgamaTimerNum++;                if (startgamaTimerNum == 1) {                    startAutoFocusUSART(1);                } else {                    boolean autoFocusResult = mCameraClient.getAutoFocusResult();                    if (autoFocusResult) {//自动对焦成功                        //设置gamma值                        int uartGamma = mCameraClient.getUartGamma(-1);                        BaseApplication.getInstance().setGamma(uartGamma);                        ConstantUtil.isAutoFocusFinish = true;                        autoTimer.cancel();                        cancel();                        mMasterActivityShowHandler.sendEmptyMessage(MasterActivity.SHOW_AUTO_FOCUS_DATA);                        captureAndRecodSelfcheck();//开始拍照录制视频自检                    }                    if (autoFocusDelayTimeCount >= 38) {//时间到,停止自动对焦                        //设置gamma值                        int uartGamma = mCameraClient.getUartGamma(-1);                        ConstantUtil.isAutoFocusFinish = true;                        BaseApplication.getInstance().setGamma(uartGamma);                        mCameraClient.sendAutoFocusMessege(1, 0, 0, false, ConstantUtil.MOVE_SPEED);//发送停止自动对焦指令                        autoTimer.cancel();                        cancel();                        mMasterActivityShowHandler.sendEmptyMessage(MasterActivity.SHOW_AUTO_FOCUS_DATA);                        captureAndRecodSelfcheck();                    }                }            }        }, 8000, 1000);      //    }    private void captureAndRecodSelfcheck() {        //对焦之后开始拍照        phoneTimer.scheduleAtFixedRate(new TimerTask() {            @Override            public void run() {                if (mCameraClient != null) {                    if (!mCameraClient.isRecording()) {     //正在录像的时候 , 不能拍照 ; 录像优先 ;                        capture();  //拍照 ;                        selfcheckSaturation++;                        if (selfcheckSaturation > ConstantUtil.LIGHTSCOUNT) {                            phoneTimer.cancel();                            mMasterActivityBinder.setSaturation(1);                            if (mMasterActivityShowHandler != null) {                                //创建信息 :                                Message msg = new Message();                                msg.what = MasterActivity.UPDATE_AUTO_DISPLAY;                                msg.arg1 = 1;                                //向新线程中的Handler发送消息 ;                                mMasterActivityShowHandler.sendMessage(msg);                            }                            //定时录像自检 :                            record();       // 开始录像 :                            recordTimer.scheduleAtFixedRate(new TimerTask() {                                @Override                                public void run() {                                    if (mCameraClient != null) {                                        if (mCameraClient.isRecording()) {                                            mMasterActivityBinder.record();       // 停止录像 :                                            recordTimer.cancel();                                            if (ConstantUtil.isSelefCheck) {                                                startSelfCheck();                                            }                                        }                                    }                                }                            }, 20000, 20000);//20秒之后关闭                            return;                        }                        mMasterActivityBinder.setSaturation(selfcheckSaturation);                        if (mMasterActivityShowHandler != null) {                            //创建信息 :                            Message msg = new Message();                            msg.what = MasterActivity.UPDATE_AUTO_DISPLAY;                            msg.arg1 = selfcheckSaturation;                            //向新线程中的Handler发送消息 ;                            mMasterActivityShowHandler.sendMessage(msg);                        }                    }                }            }        }, 0, 8000);    }    //停止自检程序 :    public void stopSelfCheck() {        if (autoTimer != null) {            //设置gamma值            int uartGamma = mCameraClient.getUartGamma(-1);            BaseApplication.getInstance().setGamma(uartGamma);            //ConstantUtil.UARTGAMMA = uartGamma;            mCameraClient.sendAutoFocusMessege(1, 0, 0, false, ConstantUtil.MOVE_SPEED);//发送停止自动对焦指令            mMasterActivityShowHandler.sendEmptyMessage(MasterActivity.SHOW_AUTO_FOCUS_DATA);            autoTimer.cancel();        }        if (mCameraClient.isRecording()) {            mMasterActivityBinder.record();       // 停止录像 :        }        if (gammaTimer != null) {            //对焦控制耐久测试 :            gammaTimer.cancel();            gammaTimer = null;            //stopFocus();        }        if (contrastTimer != null) {            //物镜切换控制耐久测试 :            contrastTimer.cancel();            contrastTimer = null;        }        if (saturationTimer != null) {            //物镜切换控制耐久测试 :            saturationTimer.cancel();            saturationTimer = null;        }        if (phoneTimer != null) {            //定时拍照测试 :            phoneTimer.cancel();            phoneTimer = null;        }        if (recordTimer != null) {            recordTimer.cancel();            recordTimer = null;        }        //2016.07.08 : 新增 : 拍摄图像 标识位 :        isSelfCheckFlag = false;     //退出测试程序 ;    }    /**     * 保存 字段：1物镜倍数  2 激发块  3 着色 4 增益  5 亮度  6染料名称 7     */    // TODO: 2016/7/10  : 增加默认参数设置 和 默认参数获取 :    //获取相机状态 , 保存到数据库中 ;    //保存当前用户名所选激发块数据到数据库    public void mPutConfigurationParameter() {        //获取当前选择的物镜倍数 :        int mgain = 0;        int mul = BaseApplication.getInstance().getContrast();        //获取当前选择的激发块 :        int saturation = BaseApplication.getInstance().getSaturation();        switch (saturation) {            case 1:                mgain = 0;                break;            case 2:                mgain = 16;                break;            case 3:                mgain = 32;                break;            case 4:                mgain = 64;                break;        }        //获取当前选择的着色 :        //Object rgb = SPUtils.get(getApplicationContext(), "recolor", MasterIntentService.RECOLOR_WHITE);        //final int color = (rgb == null ? MasterIntentService.RECOLOR_WHITE : (int) rgb);        int color = BaseApplication.getInstance().getRecolor();        int sensitivity = BaseApplication.getInstance().getGain();        //获取当前的亮度值 : brightness :        //Object objBrightness = SPUtils.get(getApplicationContext(), "brightness", 0);        //int brightness = (objBrightness == null ? 0 : (int) objBrightness);        int brightness = BaseApplication.getInstance().getBrightness();        int gamma = BaseApplication.getInstance().getGamma();        //2016.11.25 : 添加选择的染料名称记录 :        //Object objReColorString = SPUtils.get(getApplicationContext(), "currentReColorString", "No-Color");        //String reColorString = (objReColorString == null ? "No-Color" : (String) objReColorString);        String reColorString = BaseApplication.getInstance().getCurrentReColorString();        String multipleString = MULTIPLE_STRING_5X;        switch (mul) {            //5 x 倍物镜 :            case 5:                multipleString = MULTIPLE_STRING_5X;                break;            //10 x 倍物镜 :            case 10:                multipleString = MULTIPLE_STRING_10X;                break;            //20 x 倍物镜 :            case 20:                multipleString = MULTIPLE_STRING_20X;                break;            //40 x 倍物镜 :            case 40:                multipleString = MULTIPLE_STRING_40X;                break;            //50 x 倍物镜 :            case 50:                multipleString = MULTIPLE_STRING_50X;                break;        }        String saturationString = LIGHT_STRING_WHITE;        switch (saturation) {            //饱和灯光 颜色 : 白色            case LIGHT_SATURATION_WHITE:                saturationString = LIGHT_STRING_WHITE;                break;            //饱和灯光 颜色 : 蓝色            case LIGHT_SATURATION_BLUE:                saturationString = LIGHT_STRING_BLUE;                break;            //饱和灯光 颜色 : 黑色            case LIGHT_SATURATION_BLACK:                saturationString = LIGHT_STRING_BLACK;                break;            //饱和灯光 颜色 : 绿色            case LIGHT_SATURATION_GREEN:                saturationString = LIGHT_STRING_GREEN;                break;            //2016.06.08 : 新增 :            //饱和灯光 颜色 : 紫色            case LIGHT_SATURATION_PURPLE:                saturationString = LIGHT_STRING_PURPLE;                break;        }        String userName = ConstantUtil.getCurrentUserName(getApplicationContext());        int msaturation = BaseApplication.getInstance().getSaturation();        ConfigurationParameter parameter = new ConfigurationParameter();        parameter.setUser(userName);        parameter.setMultiple(mul + "");      //设置物镜倍数 ;        parameter.setStimulatedLight(msaturation);     //设置激发块灯光 ;        parameter.setTinting(color);    //设置着色设置 ;        parameter.setSensitivity(sensitivity);  //设置ISO增益值 ;        parameter.setBrightness(brightness);    //设置亮度值 ;        parameter.setTintingString(reColorString);    //设置选择的染料 ;        parameter.setGamma(gamma);//设置焦点值        MSQLUtil.mPut(getApplicationContext(), parameter);        String stateStr = ConstantUtil.getStateStr();        FileUtils.writeFileToLogFolder("保存当前用户名所选激发块数据到数据库 :" + stateStr);    }    //从数据库中读取数据，设置摄像头参数    public void msetConigurationParameter() {        String userName = ConstantUtil.getCurrentUserName(getApplicationContext());        int saturation = BaseApplication.getInstance().getSaturation();        int contrast = BaseApplication.getInstance().getContrast();        ConfigurationParameter getParameter = MSQLUtil.mGet(getApplicationContext(), userName, String.valueOf(saturation), String.valueOf(contrast));        //数据库没有查询到该条记录则返回        if (getParameter == null) {            int tinting = 0;            int iso = 0;            int brightness = 0;            String str = "";            switch (saturation) {                case 0:                    str = "No-Color";                    break;                case 1:                    tinting = -1;                    str = "No-Color";                    iso = 0;                    brightness = 50;                    break;                case 2:                    tinting = -16711936;                    str = "AlexaFluor488";                    iso = 48;                    brightness = 5000;                    break;                case 3://绿                    tinting = -65536;                    str = "AlexaFluor594";                    iso = 48;                    brightness = 5000;                    break;                case 4:                    tinting = -16776961;                    str = "DAPI";                    iso = 48;                    brightness = 5000;                    break;            }            mCameraClient.clientColor(tinting);            mCameraClient.setGain(iso);            mCameraClient.setBrightness(brightness);            BaseApplication.getInstance().setRecolor(tinting);            BaseApplication.getInstance().setCurrentReColorString(str);            mCameraClient.setRecolorString(str);            BaseApplication.getInstance().setGain(iso);            BaseApplication.getInstance().setBrightness(brightness);            mPutConfigurationParameter();            return;        }        if (mCameraClient != null) {            //设置亮度值 :            int brightness = getParameter.getBrightness();            Log.w(TAG, "mCameraClient.setBrightness=" + brightness);            mCameraClient.setBrightness(brightness);            BaseApplication.getInstance().setBrightness(brightness);            //设置ISO增益值 gain :            int sensitivity = getParameter.getSensitivity();            Log.w(TAG, "mCameraClient.sensitivity=" + sensitivity);            mCameraClient.setGain(sensitivity);            BaseApplication.getInstance().setGain(sensitivity);            String multiple = getParameter.getMultiple();            if (multiple.length() > 0 && !multiple.equals("0")) {                // mCameraClient.setContrast(Integer.valueOf(multiple));                // BaseApplication.getInstance().setContrast(Integer.valueOf(multiple));            }            //设置recolor着色值 :            int tinting = getParameter.getTinting();            String tintingString = getParameter.getTintingString();            //如果没有设置则按照默认值着色            mCameraClient.clientColor(tinting);            BaseApplication.getInstance().setRecolor(tinting);            BaseApplication.getInstance().setCurrentReColorString(tintingString);            mCameraClient.setRecolorString(tintingString);            Log.w(TAG, "mCameraClient.getBrightness=" + mCameraClient.getBrightness());            Log.w(TAG, "mCameraClient.getISO=" + mCameraClient.getGain());        }    }    //定义接收屏保广播的接收器 : 监听接收屏幕亮、屏幕灭、屏幕 解锁三个事件ACTION_SCREEN_ON、ACTION_SCREEN_OFF、ACTION_USER_PRESENT三个Action ;    ScreenAlarmReceiver mMasterResetReciever;    // TODO: 2016/6/14  通过后台守护服务 ,开启双线程来实现n分钟无操作后 , 进入应用休眠模式 (包括屏保 , 灯光灭灯等);    /*标识当前是否进入了屏保*/    private boolean isRunScreenSaver;    private void startScreenService() {        mMasterResetReciever = new ScreenAlarmReceiver();        //启动screen状态广播接收器        startScreenBroadcastReceiver();        mKeyguardManager = (KeyguardManager) getSystemService(Context.KEYGUARD_SERVICE);        mKeyguardLock = mKeyguardManager.newKeyguardLock("");        mKeyguardLock.disableKeyguard();        //Intent.ACTION_SCREEN_OFF        //2016.09.21 : 修改 :    }    /**     * 启动screen状态广播接收器     */    private void startScreenBroadcastReceiver() {        IntentFilter filter = new IntentFilter();        filter.addAction(WifiManager.NETWORK_STATE_CHANGED_ACTION);        filter.addAction(ConnectivityManager.CONNECTIVITY_ACTION);//增加监听网络状态        filter.addAction(Intent.ACTION_SCREEN_ON);        filter.addAction(Intent.ACTION_SCREEN_OFF);        filter.addAction(Intent.ACTION_USER_PRESENT);       //ACTION_USER_PRESENT是解锁动作 ;        filter.setPriority(IntentFilter.SYSTEM_HIGH_PRIORITY);  //设置动态接收器的优先级为最高 ;        getApplicationContext().registerReceiver(mMasterResetReciever, filter);    }    private int getNetWorkState(Context context) {        // 得到连接管理器对象        ConnectivityManager connectivityManager = (ConnectivityManager) context                .getSystemService(Context.CONNECTIVITY_SERVICE);        NetworkInfo activeNetworkInfo = connectivityManager                .getActiveNetworkInfo();        if (activeNetworkInfo != null && activeNetworkInfo.isConnected()) {            if (activeNetworkInfo.getType() == (ConnectivityManager.TYPE_WIFI)) {                return 1;            } else if (activeNetworkInfo.getType() == (ConnectivityManager.TYPE_MOBILE)) {                return 0;            }        } else {            return -1;        }        return -1;    }    /**     * UsbControlBlock :     * USB 控制模块 :     */    public final class ScreenAlarmReceiver extends BroadcastReceiver {        @Override        public void onReceive(Context context, Intent intent) {            // UIUtil.toast(mMasterIntentService, "监听成功!");            if (WifiManager.NETWORK_STATE_CHANGED_ACTION.equals(intent.getAction())) {                Parcelable parcelableExtra = intent                        .getParcelableExtra(WifiManager.EXTRA_NETWORK_INFO);                if (null != parcelableExtra) {                    NetworkInfo networkInfo = (NetworkInfo) parcelableExtra;                    NetworkInfo.State state = networkInfo.getState();                    boolean isConnected = state == NetworkInfo.State.CONNECTED;// 当然，这边可以更精确的确定状态                    //UIUtil.toast(context,"isConnected="+isConnected+"  "+ConstantUtil.isEnbleListening,true);                    if (isConnected) {                        if (!ConstantUtil.isEnbleListening) {                            if (ConstantUtil.remoteUserName != null) {                                FileUtils.writeFileToLogFolder("网络已经链接，监听客户端是否登录");                                listnessReMoteLogin();                            }                        }                    } else {                    }                }            }            //ACTION_SCREEN_ON 开屏            if (Intent.ACTION_SCREEN_ON.equals(intent.getAction())) {    //接收到ACTION_SCREEN_ON广播 ;                // Log.w("test", "MasterIntentService mMasterResetReciever = ACTION_SCREEN_ON ++++");            }            //ACTION_SCREEN_OFF 锁屏            else if (Intent.ACTION_SCREEN_OFF.equals(intent.getAction())) {     //接收到ACTION_SCREEN_OFF广播 ;                // TODO: 2016/6/15 : 接收到锁屏广播 , 暂停超时计时 ; 关闭LED , 关闭激发块 , 关闭系统 , 进入休眠 :                if (mMasterActivityBinder != null)                    mMasterActivityBinder.stopAutoFocus();//锁屏前停止自动对焦                if (isRunScreenSaver == false) {                    //进入屏保标识 :                    isRunScreenSaver = true;                }                //2016.09.13 : 新增 : 添加熄屏保存当前Surface :                if (mCameraView != null) {                    if (mCameraView.getSurface() != null) {                        int surfaceCode = mCameraView.getSurface().hashCode();                        // SPUtils.put(mMasterIntentService, "CurrentSurfaceCode", surfaceCode);                        BaseApplication.getInstance().setCurrentSurfaceCode(surfaceCode);                        System.gc();                        // mCameraClient.removeSurface(mCameraView.getSurface());                        System.gc();                        //Log.i("test", "MasterIntentService mMasterResetReciever = ACTION_SCREEN_OFF surfaceCode = " + surfaceCode);                    } else {                        // Log.i("test", "MasterIntentService mMasterResetReciever = ACTION_SCREEN_OFF mCameraView.getSurface() == null ++++");                    }                    //                mCameraClient.removeSurface(mCameraView.getSurface());                    //                        mCameraClient.addSurface(mCameraView.getSurface(), false);                } else {                    Log.i("test", "MasterIntentService mMasterResetReciever = ACTION_SCREEN_OFF mCameraView == null ++++");                }                //待机熄灯 ;                if (mCameraClient != null && (ConstantUtil.UVCServiceConnectStion == 1)) {                    // Object autoPhoto_views = SPUtils.get(getBaseContext(), "autoPhoto_views", 0);                    //  int autoPhotoState = (int) autoPhoto_views;                    //如果不是正在自动拍照则熄灯                    if (BaseApplication.getInstance().getAutoPhoto_views() != 3)                        mCameraClient.setSaturation(LIGHT_SATURATION_BLACK);    //待机熄灯 ;                }            }            //ACTION_USER_PRESENT 解锁            else if (Intent.ACTION_USER_PRESENT.equals(intent.getAction())) {                // TODO: 2016/6/15 : 添加用户解锁后 , 判断应用是否重启 , 是否在前台 : 重启超时计时 ;                if (isRunScreenSaver) {                    //退出屏保标识 :                    isRunScreenSaver = false;                }                //重新开机亮灯 ;                if (mCameraClient != null && (ConstantUtil.UVCServiceConnectStion == 1)) {                    //获取当前选择的激发块 :                    // Object objSaturation = SPUtils.get(getApplicationContext(), "saturation", 0);                    //  int saturation = (objSaturation == null ? 0 : (int) objSaturation);                    int saturation = BaseApplication.getInstance().getSaturation();                    mCameraClient.setSaturation(saturation);    //重新开机亮灯 ;                }                //2016.09.13 : 新增 : 添加亮屏校验当前Surface :                if (mCameraView != null) {                    if (mCameraView.getSurface() != null) {                        int surfaceCode = mCameraView.getSurface().hashCode();                        //获取熄屏时保存的surafceCode :                        // Object objLastSurfaceCode = SPUtils.get(getApplicationContext(), "CurrentSurfaceCode", 0);                        // int lastSurfaceCode = (objLastSurfaceCode == null ? 0 : (int) objLastSurfaceCode);                        int lastSurfaceCode = BaseApplication.getInstance().getCurrentSurfaceCode();                        if (surfaceCode != lastSurfaceCode) {                            // Log.i("test", "MasterIntentService mMasterResetReciever = ACTION_USER_PRESENT ERROR ERROR ==== " +                            //        "\n surfaceCode = " + surfaceCode + " lastSurfaceCode = " + lastSurfaceCode);                            String showErrorString = "ERROR ERROR ==== \n surfaceCode = " + surfaceCode + "\n lastSurfaceCode = " + lastSurfaceCode;                            //Toast.makeText(getApplicationContext(), showErrorString, Toast.LENGTH_SHORT).show();                        } else {                            //  Log.i("test", "MasterIntentService mMasterResetReciever = ACTION_USER_PRESENT surfaceCode = " + surfaceCode);                        }                        if (mCameraClient != null && (ConstantUtil.UVCServiceConnectStion == 1)) {                            //            mCameraClient.removeSurface(mCameraView.getSurface());                            Log.i("test", "MasterIntentService mMasterResetReciever = ACTION_SCREEN_ON ");                            if (mCameraView.getSurface() != null && ConstantUtil.isAllowOperation)                                mCameraClient.addSurface(mCameraView.getSurface(), false);                        }                    } else {                        //  Log.i("test", "MasterIntentService mMasterResetReciever = ACTION_USER_PRESENT mCameraView.getSurface() == null ++++");                    }                    //2016.09.14 : 新增 : 用于待机唤醒后重新设置并开始预览图像 :                    if (mCameraClient != null && (ConstantUtil.UVCServiceConnectStion == 1) && ConstantUtil.isAllowOperation) {                        mCameraClient.restartPreview();                        Log.i("test", "+++++++++++++++++++++++++MasterIntentService restartPreview");                    }                } else {                }                //                    }            } else {                lightScreen();                //设置通知内容并在onReceive()这个函数执行时开启                NotificationManager manager = (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);                Notification notification = new Notification(R.drawable.ic_launcher, "程序在后台运行中 ！！"                        , System.currentTimeMillis());                notification.setLatestEventInfo(context, "点击进入后台程序管理",                        "强制关闭程序 ！", null);                notification.defaults = Notification.DEFAULT_ALL;                manager.notify(1, notification);            }        }    }    private void lightScreen() {        /**         * WakeLock如果是一个没有超时的锁 , 而且这个锁没有释放 , 那么系统就无法进入休眠 ; WakeLock这个锁机制 可以被用户态程序和内核获得 ;         * 这个锁可以是超时的或者没有超时的 , 超时的锁会在超时以后自动解锁. 如果没有了锁 或者超时了 , 内核就会启动休眠的那套机制来进入休眠 ;         */        //点亮        // 获取PowerManager的实例        PowerManager pm = (PowerManager) getSystemService(Context.POWER_SERVICE);        PowerManager.WakeLock wakeLock = pm.newWakeLock(PowerManager.FULL_WAKE_LOCK | PowerManager.ACQUIRE_CAUSES_WAKEUP, "bright");        if (!wakeLock.isHeld()) {            // 唤醒屏幕            wakeLock.acquire();     //获取唤醒锁        }        KeyguardManager km = (KeyguardManager) getSystemService(Context.KEYGUARD_SERVICE);        KeyguardManager.KeyguardLock kl = km.newKeyguardLock("unlock");        //        kl.disableKeyguard();        if (km.inKeyguardRestrictedInputMode()) {            // 解锁键盘            kl.disableKeyguard();        }        kl.reenableKeyguard();        wakeLock.release();     //释放唤醒锁    }    @Override    public void onError(final String msg) {        mCurrentActivity.runOnUiThread(new Runnable() {            @Override            public void run() {                showErrorDialog(msg);            }        });    }    @Override    public void onError(Exception exc) {        final String msg = exc.getClass().getSimpleName() + ": " + exc.getMessage();        onError(msg);    }    @Override    public void onNotRoot() {        mCurrentActivity.runOnUiThread(new Runnable() {            @Override            public void run() {                showNotRootedDialog();            }        });    }    private AlertDialog.Builder buildErrorDialog(String msg) {        return new AlertDialog.Builder(mCurrentActivity).setMessage(msg).setOnKeyListener(new DialogInterface.OnKeyListener() {            @Override            public boolean onKey(DialogInterface dialog, int keyCode, KeyEvent event) {                return false;            }        }).setCancelable(true)                .setNeutralButton(R.string.ok, new DialogInterface.OnClickListener() {                    @Override                    public void onClick(DialogInterface dialog, int id) {                        dialog.dismiss();                    }                });    }    private void showErrorDialog(String msg) {        AlertDialog.Builder builder = buildErrorDialog(msg);        AlertDialog alert = builder.create();        alert.show();    }    private void showNotRootedDialog() {        final Uri uri = Uri.parse(getString(R.string.rooting_url));        AlertDialog.Builder builder = buildErrorDialog(getString(R.string.not_rooted));        builder.setNegativeButton(R.string.what, new DialogInterface.OnClickListener() {            @Override            public void onClick(DialogInterface dialog, int which) {                startActivity(new Intent(Intent.ACTION_VIEW, uri));                dialog.dismiss();            }        });        AlertDialog alert = builder.create();        alert.show();    }    //白激发光 默认选择的 着色 :    public static final int RECOLOR_WHITE = 0xffffffff;    //白激发光 默认选择的 着色 :    public static final int RECOLOR_RED = 0xffff0000;    //白激发光 默认选择的 着色 :    public static final int RECOLOR_GREEN = 0xff00ff00;    //白激发光 默认选择的 着色 :    public static final int RECOLOR_BLUE = 0xff00ffff;    private PowerManager mPowerManager;    private PowerManager.WakeLock mWakeLock;    private KeyguardManager mKeyguardManager;    private KeyguardManager.KeyguardLock mKeyguardLock;    //2016.09.19 : 申请获取电源锁，保持该服务在屏幕熄灭时仍然获取CPU时，保持运行 ;    private void acquireWakeLock() {        /**         * WakeLock如果是一个没有超时的锁 , 而且这个锁没有释放 , 那么系统就无法进入休眠 ; WakeLock这个锁机制 可以被用户态程序和内核获得 ;         * 这个锁可以是超时的或者没有超时的 , 超时的锁会在超时以后自动解锁. 如果没有了锁 或者超时了 , 内核就会启动休眠的那套机制来进入休眠 ;         */        //点亮        // 获取PowerManager的实例        mPowerManager = (PowerManager) getSystemService(Context.POWER_SERVICE);        //        mWakeLock = mPowerManager.newWakeLock(PowerManager.FULL_WAKE_LOCK, TAG);        //        mWakeLock = mPowerManager.newWakeLock(PowerManager.FULL_WAKE_LOCK | PowerManager.ACQUIRE_CAUSES_WAKEUP, TAG);        mWakeLock = mPowerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, TAG);        //        wakeLock.acquire();     //获取唤醒锁        if (!mWakeLock.isHeld()) {            // 唤醒屏幕            mWakeLock.acquire();     //获取唤醒锁        }        mKeyguardManager = (KeyguardManager) getSystemService(Context.KEYGUARD_SERVICE);        mKeyguardLock = mKeyguardManager.newKeyguardLock("unlock");        //        kl.disableKeyguard();        if (mKeyguardManager.inKeyguardRestrictedInputMode()) {            // 解锁键盘            mKeyguardLock.disableKeyguard();        }    }    // 释放设备电源锁          //2016.09.19 : 释放唤醒锁 ;    private void releaseWakeLock() {        if (null != mWakeLock && mWakeLock.isHeld()) {            mWakeLock.release();            mWakeLock = null;        }        if (null != mKeyguardLock) {            mKeyguardLock.reenableKeyguard();            mKeyguardLock = null;        }    }}